#######################################################################
##           InsertAnatomy.pm
##
##
#######################################################################

package GUS::Community::Plugin::InsertAnatomy;
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;

use FileHandle;
use GUS::PluginMgr::Plugin;
use GUS::Model::SRes::Anatomy;
use GUS::Model::SRes::ExternalDatabaseRelease;
use GUS::Model::SRes::ExternalDatabase;

my $purposeBrief = <<PURPOSEBRIEF;
Loads Anatomy Terms into DB and creates relationships among them.
PURPOSEBRIEF

my $purpose = <<PLUGIN_PURPOSE;
This plugin load anatomical terms from a file generated by DumpAnatomy into the database.  Anatomycal terms are organised into a graph and parent-child relationship are preserved.
PLUGIN_PURPOSE

my $tablesAffected =
	[['SRes.Anatomy', 'Anatomy terms are written here']
	];

my $tablesDependedOn = [ ];


my $argsDeclaration = [
		       fileArg({name => 'inputFile',
				descr => 'The anatomy file to be loaded',
				reqd => 1,
				constraintFunc => undef,
				isList => 0,
				mustExist => 1,
				format => 'see NOTES'
			    })
		       
		       ];

my $howToRestart = <<PLUGIN_RESTART;
Restart the plugin.
PLUGIN_RESTART

my $failureCases = <<PLUGIN_FAILURE_CASES;
Unknown.
PLUGIN_FAILURE_CASES

my $notes = <<PLUGIN_NOTES;
The file format is hierarchy:source:definition, with hierarchy a semicolon delimited list of hierarchical IDs. The format is defined in GUS::Community::Plugin::Report::DumpAnatomy.
PLUGIN_NOTES


my $documentation = {purposeBrief => $purposeBrief,
		     purpose => $purpose,
		     tablesAffected => $tablesAffected,
		     tablesDependedOn => $tablesDependedOn,
		     howToRestart => $howToRestart,
		     failureCases => $failureCases,
		     notes => $notes
		    };


################################################################
# new
################################################################
sub new {
    my ($class) = @_;
    my $self = {};
    bless($self, $class);
    
    $self->initialize(
		      {requiredDbVersion => 3.6,
		       cvsRevision =>  '$Revision: 5224 $', #CVS fills this in
		       name => ref($self),
		       argsDeclaration   => $argsDeclaration,
		       documentation     => $documentation,
		   });
    
    return $self;
}


################################################################
# run
################################################################
sub run {
    my ($self) = @_;
           
    my $n = $self->readFile($self->getArg('inputFile'));
    
    my $msg = "$n entries populated";
    return $msg;
}


sub readFile {
    my ($self, $fileName) = @_;
    
    open (FILE, "<$fileName") || die "Cannot open inout File $fileName: $!";
    
    my @data = <FILE>;
    chomp @data;
    close(FILE);
    
    $self->log("parsing data file...\n");
    
    my $inserted=0;
    
    foreach(@data) {
	my @cur = split(/\t/, $_);
	my @ids = split(/\;\;/, $cur[0]);
	my $source = $cur[1];
	my $description = $cur[2];
	
	my $currentID = $ids[$#ids];
	
	my $hierLevel = $#ids;
	
        # test if this term is already in the db
	
	my $sql = "SELECT * FROM SRes.Anatomy WHERE NAME = '$currentID' AND HIER_LEVEL = $hierLevel";
	if($hierLevel != 0) {
	    for(my $i=1; $i<scalar @ids; $i++) {
		$sql = $sql." AND LEVEL_$i = '$ids[$i]'";
	    }
	}
		
	my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
	my ($result) = $sth->fetchrow_array();
	
	if(!defined $result) {
	    
	    # term '$currentID' not in the db, so populate the db
	    # check if the immediate parent is in the db and get its id
	    my $parentID;
	    
	    if($#ids>0) {
		my $parentName = $ids[$#ids-1];
		my $parentHierLevel = $#ids-1;
		
		my $sql = "SELECT ANATOMY_ID FROM SRes.Anatomy WHERE NAME = '$parentName' AND HIER_LEVEL = $parentHierLevel";
		if($parentHierLevel>0) {
		    for(my $i=1; $i<scalar @ids-1; $i++) {
			$sql = $sql." AND LEVEL_$i = \'$ids[$i]\'";
		    }
		}
		
		my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
		$parentID = $sth->fetchrow_array();
		
		if(!defined $parentID) {
		    die "parent '$parentName' of '$currentID' not in the database\n"; 
		}
	    }
	    
	    #populate entry
	    my $newAnatomy = GUS::Model::SRes::Anatomy->new({
		'name'        => $currentID,
		'hier_level'  => $hierLevel,
		'parent_ID'   => $parentID,
		'source'      => $source,
		'description' => $description,
	    });
	    
	    if($hierLevel != 0) {
		for(my $i=1; $i<scalar @ids; $i++) {
		    my $attributeName = "level_$i";
		    $newAnatomy->set($attributeName, "$ids[$i]");
		}
	    }
	    
	    $newAnatomy->submit();
	    $inserted++;
	}
	
	else {
	    $self->log("term '$currentID' already in DB");
	}
    }
    
    return $inserted;
}


sub undoTables {
    my ($self) = @_;

    return ('SRes.Anatomy');
}
