package GUS::Common::Plugin::LoadBlastSimFast;

@ISA = qw(GUS::PluginMgr::Plugin); 
use strict;

use FileHandle;

sub new {
  my ($class) = @_;
  my $self = {};
  bless($self,$class);

  my $usage = 'Load in blast similarities generated by generateBlastSimilarity.pl  NOTE: Both query and subject must use primary key as identifier';

  my $easycsp =
    [{o => 'subject_table',
      t => 'string',
      h => 'subjects are taken from this table (schema::table format).',
     },
     {o => 'batch_size',
      t => 'int',
      h => 'Number of spans to write in one transaction',
      d => 1000,
     },
     {o => 'log_frequency',
      t => 'int',
      h => 'Write line to log file once every this many entries',
      d => 10,
     },
     {o => 'query_table',
      t => 'string',
      h => 'queries are taken from this table (schema::table format). ',
     },
     {o => 'file',
      t => 'string',
      h => 'read condensed results from this file',
      l => 1,
     },
     {o => 'nqueries',
      t => 'int',
      h => 'process this many queries',
      d => 1e6,
     },
     {o => 'output',
      t => 'string',
      h => 'what type of similarity children to put in db',
      d => 'both',
      e => [ qw ( both summaries spans ) ],
     },
     {o => 'restart',
      t => 'string',
      h => 'restarts from last entry in Similarity.... takes list of row_alg_invocation_ids "234, 235"!',
     },
     {o => 'limit_sub',
      t => 'int',
      h => 'maximum number of subjects to enter / query'
     },
     {o => 'limit_hsp',
      t => 'int',
      h => 'maximum number of hsps to enter / subject'
     },
     {o => 'ns_mi',
      t => 'int',
      h => 'minimum number of subject filter'
     },
     {o => 'ns_ma',
      t => 'int',
      h => 'maximum number of subject filter'
     },
     {o => 'su_pv',
      t => 'float',
      h => 'summary pvalue cutoff'
     },
     {o => 'su_pi',
      t => 'float',
      h => 'summary percent identity cutoff'
     },
     {o => 'su_ln',
      t => 'int',
      h => 'summary match length cutoff'
     },
     {o => 'sp_pv',
      t => 'float',
      h => 'span pvalue cutoff'
     },
     {o => 'sp_pi',
      t => 'float',
      h => 'span percent identity cutoff'
     },
     {o => 'sp_ln',
      t => 'int',
      h => 'span match length cutoff'
     },
    ];

  $self->initialize({requiredDbVersion => {},
		     cvsRevision => '$Revision$', # cvs fills this in!
		     cvsTag => '$Name$', # cvs fills this in!
		     name => ref($self),
		     revisionNotes => 'initial writing',
		     easyCspOptions => $easycsp,
		     usage => $usage
		    });
  return $self;
}

$| = 1;

sub run {
  my ($self) = @_;
  

  my $args = $self->getArgs();
  my $algInv = $self->getAlgInv();
  my $dbh = $self->getDb()->getDbHandle();

  my %filter = &setupFilters($args);

  my $query_tbl_id = $algInv->getTableIdFromTableName($args->{query_table});
  my $subj_tbl_id = $algInv->getTableIdFromTableName($args->{subject_table});

  $self->logCommit();

  print "Testing on $args->{'testnumber'}\n" if $args->{'testnumber'};

  my %ignore = &handleRestart($args->{restart}, $dbh);

  my $fh  = $args->{file} =~ /\.gz$|\.Z$/ ?
    FileHandle->new("zcat $args->{file}|") : FileHandle->new("$args->{file}");

  die "Can't open file $args->{file}" unless $fh;

  while(1) {
    my @subjects = &parseQueries($fh, $args->{batch_size}, \%ignore, \%filter);
    last unless @subjects;
    $self->insertSubjects($dbh, \@subjects, $query_tbl_id, $subj_tbl_id);
  }
}

sub setupFilters {
  my ($args) = @_;

  my $filter_ns;
  $filter_ns->{min} = $args->{ns_mi} if defined $args->{ns_mi};
  $filter_ns->{max} = $args->{ns_ma} if defined $args->{ns_ma};

  my $filter_su;
  $filter_su->{length} = $args->{su_ml} if defined $args->{su_ml};
  $filter_su->{pValue} = $args->{su_pv} if defined $args->{su_pv};
  $filter_su->{percentIdentity} = $args->{su_pi} if defined $args->{su_pi};

  my $filter_sp;
  $filter_sp->{length} = $args->{sp_ml} if defined $args->{sp_ml};
  $filter_sp->{pValue} = $args->{sp_pv} if defined $args->{sp_pv};
  $filter_sp->{percentIdentity} = $args->{sp_pi} if defined $args->{sp_pi};

  my $filter_limit;
  $filter_limit->{subjects} = $args->{limit_sub} if defined $args->{limit_sub};
  $filter_limit->{hsps} = $args->{limit_hsp} if defined $args->{limit_hsp};

}

sub handleRestart {
  my ($restart, $dbh) = @_;

  my %ignore;
  if ($restart) {
    my $query = "select distinct query_id from dots.Similarity where row_alg_invocation_id in ($restart})";
    print "Restarting: Querying for the ids to ignore\n$query\n";
    my $stmt = $dbh->prepare($query);
    $stmt->execute();
    while ( my($id) = $stmt->fetchrow_array()) {
      $ignore{$id} = 1;
    }
    print "Ignoring ".scalar(keys%ignore)." entries\n";
  }
  return %ignore;
}

sub parseQueries {
  my ($fh, $batchSize) = @_;

  my $batchSpanCount = 0;

  my @subjects;
  while ($batchSpanCount < $batchSize) {
    my ($spanCount, $querySubjects, $eof) = &parseQuery($fh);
    last if $eof;
    $batchSpanCount += $spanCount;
    push(@subjects, @$querySubjects);
  }
  return @subjects;
}

sub parseQuery {
  my ($fh) = @_;

  my @subjects;
  my $spanCount;

  my $queryLine = <$fh>;

  if ($queryLine) {
    #>99929462 (2 subjects)
    $queryLine =~ /^\>*(\S+)\s\((\d+)/;

    my $id = $1;
    my $subjCount = $2;

    my $c = 0;
    while ($c++ < $subjCount) {
      my ($subjSpanCount, $subject) = &parseSubject($fh, $id);
      $spanCount += $subjSpanCount;
      push(@subjects, $subject);
    }
  }

  return ($spanCount, \@subjects, !$queryLine);
}

sub parseSubject {
  my ($fh) = @_;

#  Sum: 13058520:483:4e-49:1:193:175:642:2:290:126:172:0:+1

  my $sumLine = <$fh>;
  my @vals = split(/:/, $sumLine);
  my %subj;
  $subj{subject_id} = $vals[1];
  $subj{score} = $vals[2];
  ($subj{pvalue_mant}, $subj{pvalue_exp}) = split(/e/, $vals[3]);
  $subj{min_subject_start} = $vals[4];
  $subj{max_subject_end} = $vals[5];
  $subj{min_query_start} = $vals[6];
  $subj{max_query_end} = $vals[7];
  $subj{number_of_matches} = $vals[8];
  $subj{total_match_length} = $vals[9];
  $subj{number_identical} = $vals[10];
  $subj{number_positive} = $vals[11];
  $subj{is_reversed} = $vals[12];
  $subj{reading_frame} = $vals[13];
  $subj{reading_frame} =~ s/\D//g;   # get rid of (+-)

  my $c = 0;
  my @subjSpans;
  while ($c++ < $subj{number_of_matches}) {
    my $span = &parseSpan($fh);
    push(@subjSpans, $span);
  }
  $subj{spans} = \@subjSpans;

  return ($subj{number_of_matches}, %subj);
}

sub parseSpan {
  my ($fh) = @_;

#   HSP1: 13058520:84:108:156:483:4e-49:1:155:175:642:0:+1

  my $sumLine = <$fh>;
  my @vals = split(/:/, $sumLine);
  my %span;
  $span{number_identical} = $vals[2];
  $span{number_positive} = $vals[3];
  $span{match_length} = $vals[4];
  $span{score} = $vals[5];
  ($span{pvalue_mant}, $span{pvalue_exp}) = split(/e/, $vals[6]);
  $span{subject_start} = $vals[7];
  $span{subject_end} = $vals[8];
  $span{query_start} = $vals[9];
  $span{query_end} = $vals[10];
  $span{is_reversed} = $vals[11];
  $span{reading_frame} = $vals[12];
  $span{reading_frame} =~ s/\D//g;   # get rid of (+-)

  return %span
}

# insert a batch of subjects (with their spans)
sub insertSubjects {
  my ($self, $dbh, $subjects, $query_table_id, $subj_table_id) = @_;

  my $simStmt = $self->getInsertSubjStmt($dbh, $query_table_id,$subj_table_id);

  my $spanStmt = $self->getInsertSpanStmt($dbh);
 
  my $nextIdStmt = $dbh->prepare("select dots.similarity_SQ.NEXTVAL from DUAL");

  foreach my $s (@$subjects) {

    my $id = &getNextId($nextIdStmt);

    $simStmt->execute($id, $s->{subject_id}, $s->{query_id},
		      $s->{score}, "",
		      $s->{pvalue_mant}, $s->{pvalue_exp},
		      $s->{min_subject_start}, $s->{max_subject_end},
		      $s->{min_query_start}, $s->{max_query_end},
		      $s->{number_of_matches}, $s->{total_match_length},
		      $s->{number_identical}, $s->{number_positive},
		      $s->{is_reversed}, $s->{reading_frame});

    foreach my $span (@{$s->{spans}}) {
      $spanStmt->execute($id, $span->{similarity_id}, $span->{match_length},
			 $span->{number_identical}, $span->{number_positive},
			 $span->{score},  "",
			 $span->{pvalue_mant}, $span->{pvalue_exp},
			 $span->{subject_start}, $span->{subject_end},
			 $span->{query_start}, $span->{query_end},
			 $span->{is_reversed}, $span->{reading_frame});
    }

#    $count++;
  }

  if ($self->getArgs()->{commit}) {
    $dbh->commit();
  } else {
    $dbh->rollback();
  }

}

sub getInsertSubjStmt {
  my ($self, $dbh, $query_tbl_id, $subj_tbl_id) = @_;

  my $algId = $self->getAlgorithm()->getId();
  my $algInvId = $self->getAlgInvocation()->getId();
  my $rowUserId = $self->getAlgInvocation()->getRowUserId();
  my $rowGroupId = $self->getAlgInvocation()->getRowGroupId();
  my $rowProjectId = $self->getAlgInvocation()->getRowProjectId();

  my $sql = 
"insert into dots.Similarity Values " .
"(?, $subj_tbl_id, ?, $query_tbl_id, ?, " .
#score, bit_score_summary, pvalue_mant, pvalue_exp, min_subject_start,
"?,     ?,                 ?,           ?,          ?, " .
#min_subject_end, min_query_start, min_query_end, number_of_matches
"?,               ?,               ?,             ?, " .
#total_match_length, number_identical, number_positive, is_reversed, reading_fr
"?,                  ?,                ?,               ?,           ?, ".
"$algId, SYSDATE, 1, 1, 1, 1, 1, 0, $rowUserId, $rowGroupId, $rowProjectId, $algInvId)";

  return $dbh->prepare($sql);
}

sub getInsertSpanStmt {
  my ($self, $dbh) = @_;

  my $algId = $self->getAlgorithm()->getId();
  my $algInvId = $self->getAlgInvocation()->getId();
  my $rowUserId = $self->getAlgInvocation()->getRowUserId();
  my $rowGroupId = $self->getAlgInvocation()->getRowGroupId();
  my $rowProjectId = $self->getAlgInvocation()->getRowProjectId();

  my $sql = 
"insert into dots.SimilaritySpan Values " .
#similarity_span_id, similarity_id, match_length, number_identical,
"?,                  ?,             ?,            ?, ".
#number_positive, score, bit_score, pvalue_mant, pvalue_exp,
"?,               ?,     ?,         ?,           ?,".
#subject_start, subject_end, query_start, query_end,
"?,             ?,           ?,           ?, " .
#is_reversed, reading_frame
"?,           ?, ".
"$algId, SYSDATE, 1, 1, 1, 1, 1, 0, $rowUserId, $rowGroupId, $rowProjectId, $algInvId";

  return $dbh->prepare($sql);
}


1;

