/*
 * Created on Oct 28, 2004
 */
package org.gusdb.dbadmin.writer;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

import org.gusdb.dbadmin.model.Column;
import org.gusdb.dbadmin.model.Constraint;
import org.gusdb.dbadmin.model.Database;
import org.gusdb.dbadmin.model.GusSchema;
import org.gusdb.dbadmin.model.GusTable;
import org.gusdb.dbadmin.model.Index;
import org.gusdb.dbadmin.model.Schema;
import org.gusdb.dbadmin.model.Sequence;
import org.gusdb.dbadmin.model.Table;

/**
 * @author msaffitz
 * @created May 2, 2005
 * @version $Revision$ $Date: 2005-10-28 09:42:07 -0400 (Fri, 28 Oct
 *          2005) $
 */
public class OracleWriter extends RelationalDatabaseWriter {

    private HashMap tablespacePermissions = new HashMap( );
    private HashMap tablePermissions      = new HashMap( );

    /**
     * @param db Description of the Parameter
     * @exception IOException Description of the Exception
     * @see org.gusdb.dbadmin.writer.SchemaWriter#writeDatabase(java.io.OutputStreamWriter,
     *      org.gusdb.dbadmin.model.Database)
     */

    protected void writeDatabase( Database db ) throws IOException {
        log.debug( "Writing database" );
        oStream.write( "-- Automatically generated by GusDBA.\n" );
        oStream.write( "-- GUS DDL for Oracle\n" );
        if ( db.getName( ) != null ) {
            oStream.write( "-- Generated for " + db.getName( ) + "\n" );
        }
        oStream.write( "\n\n" );
        createRoles( );
        oStream.write( "\n-- Schemata\n\n" );
        for ( Schema schema : db.getAllSchemas( ) ) {
            oStream.write( "CREATE USER " + schema.getName( ) + " IDENTIFIED BY temppass PASSWORD EXPIRE ACCOUNT LOCK "
                    + " QUOTA UNLIMITED ON USERS DEFAULT TABLESPACE USERS;\n" );
        }
        oStream.flush( );
        oStream.write( "\n-- Tables, Views, Indexes, and Primary Key Constraints\n\n" );
        for ( Schema schema : db.getAllSchemas( ) ) {
            writeTables( schema );
            writeViews( schema );
        }
        oStream.flush( );
        oStream.write( "\n-- Foreign Key Constraints\n\n" );
        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( GusTable table : schema.getTables( ) ) {
                if ( schema.getClass( ) == GusSchema.class ) {
                    writeFKConstraints( table );
                    writeUQConstraints( table );
                    oStream.write( "\n" );
                }
            }
        }
        oStream.flush( );
        oStream.write( "\n-- Sequences\n\n" );
        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( Iterator j = schema.getTables( ).iterator( ); j.hasNext( ); ) {
                GusTable table = (GusTable) j.next( );

                writeSequence( table.getSequence( ) );
                oStream.write( "\n" );
            }
        }
        oStream.write( "\n\n--EOF\n" );
        written = new HashSet( );
    }

    private void createRoles( ) throws IOException {
        oStream.write( "CREATE ROLE GUS_W;\n" );
        oStream.write( "CREATE ROLE GUS_R;\n" );
        oStream.write( "\n" );
    }

protected void writeTable( Table table ) throws IOException {
		if ( written.contains( table ) ) {
			return;
		}
		if ( table.getTablespace() != null &&
			!tablespacePermissions.containsKey( table.getSchema().getName() +
			table.getTablespace() ) ) {
			grantTablespace( table.getSchema().getName(), table.getTablespace() );
		}
		if ( table.getSuperclass() != null &&
			!written.contains( table.getSuperclass() ) ) {
			writeTable( table.getSuperclass() );
		}
		oStream.write( "CREATE TABLE " + table.getSchema().getName() + "." + table.getName() + " (\n" );
		writeColumns( table );
		oStream.write( ") " );
		if ( table.getTablespace() != null ) {
			oStream.write( "TABLESPACE " + table.getTablespace() + " " );
		}
		oStream.write( ";\n\n" );
        
        oStream.write("GRANT SELECT ON " + table.getSchema().getName() + "." + table.getName() + " TO GUS_R;\n");
        oStream.write("GRANT UPDATE,INSERT,DELETE ON " + table.getSchema().getName() + "." + table.getName() + " TO GUS_W;\n");
        
        oStream.write( "\n\n");
		oStream.flush();
		written.add( table );
		if ( table.getClass() == GusTable.class ) {
			writeIndexes( (GusTable) table );
            oStream.write( "\n" );
            writePKConstraint( (GusTable) table );
		}
		oStream.write( "\n" );
	}    protected void writeFKConstraints( GusTable table ) throws IOException {
        for ( Constraint constraint : table.getConstraints( ) ) {
            if ( constraint.getType( ) == Constraint.ConstraintType.FOREIGN_KEY ) {

                if ( !tablePermissions.containsKey( table.getSchema( ).getName( )
                        + constraint.getReferencedTable( ).getSchema( ).getName( )
                        + constraint.getReferencedTable( ).getName( ) ) ) {
                    grantReferences( table.getSchema( ).getName( ), constraint.getReferencedTable( ) );
                }

                writeFKConstraint( constraint );
            }
        }
    }

    protected void writeIndex( Index index ) throws IOException {
        Table table = index.getTable( );

        if ( index.getTablespace( ) != null
                && !tablespacePermissions.containsKey( table.getSchema( ).getName( ) + index.getTablespace( ) ) ) {
            grantTablespace( table.getSchema( ).getName( ), index.getTablespace( ) );
        }
        oStream.write( "CREATE INDEX " );
        if ( index.getName( ) == null ) {
            index.setName( "IND_" + random.nextInt( 100000 ) );
        }
        oStream.write( table.getSchema( ).getName( ) + "." + index.getName( ) + " ON " + table.getSchema( ).getName( )
                + "." + table.getName( ) + " (" );
        writeColumnList( index.getColumns( ) );
        oStream.write( ") " );
        if ( index.getTablespace( ) != null ) {
            oStream.write( "TABLESPACE " + index.getTablespace( ) );
        }
        oStream.write( ";\n" );
        oStream.flush( );
    }

    private void grantTablespace( String schema, String tablespace ) throws IOException {
        oStream.write( "ALTER USER " + schema + " QUOTA UNLIMITED ON " + tablespace + ";\n\n" );
        oStream.flush( );
    }

    private void grantReferences( String schema, Table table ) throws IOException {
        oStream.write( "GRANT REFERENCES ON " + table.getSchema( ).getName( ) + "." + table.getName( ) + " TO "
                + schema + ";\n\n" );
        oStream.flush( );
    }

protected void writeSequence( Sequence sequence ) throws IOException {
        super.writeSequence(sequence);
        oStream.write("\nGRANT SELECT ON " + sequence.getTable().getSchema().getName() + "." +
            sequence.getName() + " TO GUS_W;\n");
        oStream.flush( );
    }    protected String getType( Column.ColumnType type ) {
        if ( type == Column.ColumnType.DATE ) {
            return "DATE";
        }
        else if ( type == Column.ColumnType.STRING ) {
            return "VARCHAR2";
        }
        else if ( type == Column.ColumnType.CLOB ) {
            return "CLOB";
        }
        else if ( type == Column.ColumnType.BLOB ) {
            return "BLOB";
        }
        else if ( type == Column.ColumnType.CHARACTER ) {
            return "CHAR";
        }
        else if ( type == Column.ColumnType.FLOAT ) {
            return "FLOAT";
        }
        else if ( type == Column.ColumnType.NUMBER ) {
            return "NUMBER";
        }
        log.error( "Unable to get Oracle type: " + type.toString( ) );
        throw new RuntimeException( "Unable to get Oracle type: " + type.toString( ) );
    }

}
