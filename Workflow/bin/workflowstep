#!/usr/bin/perl

use lib "$ENV{GUS_HOME}/lib/perl";

use strict;
use GUS::Workflow::WorkflowHandle;
use GUS::Workflow::WorkflowStepPilot;

# these should be imported from someplace, not duplicated here
my $READY = 'READY';      # my parents are not done yet  -- default state
my $ON_DECK = 'ON_DECK';  # my parents are done, but there is no slot for me
my $FAILED = 'FAILED';
my $DONE = 'DONE';
my $RUNNING = 'RUNNING';

&usage unless (scalar(@ARGV) >= 5 && $ARGV[0] eq '-h');

my $homeDir = $ARGV[1];
my $inputType = $ARGV[2];
my $stepNamePattern = $ARGV[3];
my $stepNameFile = $ARGV[3];
my $offline;
my $stopafter;
my $state;
my $list;
my $undo;
if ($ARGV[4] eq '-l') {
    $list = 1;
} elsif ($ARGV[4] eq 'offline' || $ARGV[4] eq 'online') {
  $offline = $ARGV[4];
} elsif ($ARGV[4] eq 'stopafter' || $ARGV[4] eq 'resume') {
  $stopafter = $ARGV[4];
} else {
  $state = $ARGV[4]
}
$undo = $ARGV[5];

&usage unless ($inputType eq '-p' || $inputType eq '-f')
    && ($list || $offline || $stopafter || ($state eq 'kill' || $state eq 'ready'))
    && (!$undo || $undo eq '-u');

my $workflow = GUS::Workflow::WorkflowHandle->new($homeDir);

$workflow->getDbState();
$workflow->error("Workflow is running an Undo.  -u required")
    if $workflow->{undo_step_id} && !$undo;
$workflow->error("Workflow is not running an Undo.  -u is not allowed")
    if !$workflow->{undo_step_id} && $undo;

$workflow->checkXmlFileDigest();



my $stepNames;
if ($inputType eq '-p') {
  $stepNames = $workflow->getStepNamesFromPattern($stepNamePattern);
} else {
  $stepNames = $workflow->getStepNamesFromFile($stepNameFile);
}

my @errors;

foreach my $stepName (@$stepNames) {

    if ($list) {
	print "$stepName\n";
	next;
    }

    my $step = GUS::Workflow::WorkflowStepPilot->new($stepName, $workflow);

    if ($state eq 'ready') {
	my $errmsg = $step->pilotSetReady();
	push(@errors,$errmsg) if $errmsg;
    } elsif ($state eq 'kill') {
	my $errmsg = $step->pilotKill();
	push(@errors,$errmsg) if $errmsg;
    }

    if ($offline) {
        my $errmsg = $step->pilotSetOffline($offline);
	push(@errors,$errmsg) if $errmsg;
    }
    if ($stopafter) {
        my $errmsg = $step->pilotSetStopAfter($stopafter);
	push(@errors,$errmsg) if $errmsg;
    }
}

if (scalar(@errors)) {
  print STDOUT "\n" . join("\n", @errors) . "\n";
}

sub usage {
    print "

Change the state and/or offline status of the workflow steps whose name match the provided pattern.

Usage: workflowstep -h workflow_home_dir [ -p stepname_pattern | -f file_of_steps ] [-l | [offline|online|stopafter|resume] [ready|kill]]

Where:
  -h                   - workflow home dir
  -p stepname_pattern  - wildcard pattern using '%' as a wildcard (Oracle
                         syntax) to specify  one or more steps to change.
                         EG, %.runBlast
  -f file_of_steps     - a file containing a list of step names.
  -l                   - list mode: don't change any steps, just list the
                         names that match the pattern

Allowed state changes are:
  $FAILED  --> ready
  $RUNNING --> kill

Offline status may not be changed when the step is $RUNNING
Stop after status may not be changed when the stop is $DONE

Examples
  % workflowstep -h workflow_dir -p stepname_pattern -l

  % workflowstep -h workflow_dir -p stepname_pattern kill

  % workflowstep -h workflow_dir -f file_of_steps online

  % workflowstep -h workflow_dir -p stepname_pattern offline ready
";
    exit(1);
}




