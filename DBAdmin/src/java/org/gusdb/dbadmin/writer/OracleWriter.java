/*
 *  Created on Oct 28, 2004
 *
 */
package org.gusdb.dbadmin.writer;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;

import org.gusdb.dbadmin.model.ColumnType;
import org.gusdb.dbadmin.model.Constraint;
import org.gusdb.dbadmin.model.ConstraintType;
import org.gusdb.dbadmin.model.Database;
import org.gusdb.dbadmin.model.GusSchema;
import org.gusdb.dbadmin.model.GusTable;
import org.gusdb.dbadmin.model.Index;
import org.gusdb.dbadmin.model.Schema;
import org.gusdb.dbadmin.model.Table;

/**
 *@author     msaffitz
 *@created    May 2, 2005
 *@version    $Revision$ $Date$
 */
public class OracleWriter extends RelationalDatabaseWriter {

	private HashMap tablespacePermissions  = new HashMap();
	private HashMap tablePermissions       = new HashMap();

	
	/**
	 *@param  db               Description of the Parameter
	 *@exception  IOException  Description of the Exception
	 *@see                     org.gusdb.dbadmin.writer.SchemaWriter#writeDatabase(java.io.OutputStreamWriter,
	 *      org.gusdb.dbadmin.model.Database)
	 */

	protected void writeDatabase( Database db ) throws IOException {
		log.debug( "Writing database" );
		oStream.write( "-- Automatically generated by GusDBA.\n" );
		oStream.write( "-- GUS DDL for Oracle\n" );
		if ( db.getName() != null ) {
			oStream.write( "-- Generated for " + db.getName() + "\n" );
		}
		oStream.write( "\n\n" );
		oStream.write( "-- Schemata\n\n" );
		for ( Iterator i = db.getSchemas().iterator(); i.hasNext();  ) {
			Schema schema  = (Schema) i.next();

			oStream.write( "CREATE USER " + schema.getName() +
				" IDENTIFIED BY temppass PASSWORD EXPIRE ACCOUNT LOCK " +
				" QUOTA UNLIMITED ON USERS DEFAULT TABLESPACE USERS;\n" );
		}
		oStream.flush();
		oStream.write( "\n-- Tables, Views, Indexes, and Primary Key Constraints\n\n" );
		for ( Iterator i = db.getSchemas().iterator(); i.hasNext();  ) {
			Schema schema  = (Schema) i.next();

			writeTables( schema );
			writeViews( schema );
		}
		oStream.flush();
		oStream.write( "\n-- Foreign Key Constraints\n\n" );
		for ( Iterator i = db.getSchemas().iterator(); i.hasNext();  ) {
			Schema schema  = (Schema) i.next();

			if ( schema.getClass() == GusSchema.class ) {
				for ( Iterator j = schema.getTables().iterator(); j.hasNext();  ) {
					GusTable table = (GusTable) j.next();
					writeFKConstraints( table );
					writeUQConstraints( table );
					oStream.write( "\n" );
				}
			}
		}
		oStream.flush();
		oStream.write( "\n-- Sequences\n\n" );
		for ( Iterator i = db.getSchemas().iterator(); i.hasNext();  ) {
			Schema schema  = (Schema) i.next();

			if ( schema.getClass() == GusSchema.class ) {
				for ( Iterator j = schema.getTables().iterator(); j.hasNext();  ) {
					GusTable table  = (GusTable) j.next();

					writeSequence( table.getSequence() );
					oStream.write( "\n" );
				}
			}
		}
		oStream.write( "\n\n--EOF\n" );
		written = new HashSet();
	}

	protected void writeTable( Table table ) throws IOException {
		if ( written.contains( table ) ) {
			return;
		}
		if ( table.getTablespace() != null &&
			!tablespacePermissions.containsKey( table.getSchema().getName() +
			table.getTablespace() ) ) {
			grantTablespace( table.getSchema().getName(), table.getTablespace() );
		}
		if ( table.getSuperclass() != null &&
			!written.contains( table.getSuperclass() ) ) {
			writeTable( table.getSuperclass() );
		}
		oStream.write( "CREATE TABLE " + table.getSchema().getName() + "." + table.getName() + " (\n" );
		writeColumns( table );
		oStream.write( ") " );
		if ( table.getTablespace() != null ) {
			oStream.write( "TABLESPACE " + table.getTablespace() + " " );
		}
		oStream.write( ";\n\n" );
		oStream.flush();
		written.add( table );
		if ( table.getClass() == GusTable.class ) {
			writeIndexes( (GusTable) table );
		}
		oStream.write( "\n" );
		writePKConstraint( table );
		oStream.write( "\n" );
	}

	protected void writeFKConstraints( GusTable table ) throws IOException {
		for ( Iterator i = table.getConstraints().iterator(); i.hasNext();  ) {
			Constraint constraint  = (Constraint) i.next();

			if ( constraint.getType() == ConstraintType.FOREIGN_KEY ) {

				if ( !tablePermissions.containsKey( table.getSchema().getName() +
					constraint.getReferencedTable().getSchema().getName() +
					constraint.getReferencedTable().getName() ) ) {
					grantReferences( table.getSchema().getName(),
						constraint.getReferencedTable() );
				}

				writeFKConstraint( constraint );
			}
		}
	}
	
	protected void writeIndex( Index index ) throws IOException {
		Table table  = index.getTable();

		if ( index.getTablespace() != null &&
			!tablespacePermissions.containsKey( table.getSchema().getName() +
			index.getTablespace() ) ) {
			grantTablespace( table.getSchema().getName(), index.getTablespace() );
		}
		oStream.write( "CREATE INDEX " );
		if ( index.getName() == null ) {
			index.setName( "IND_" + random.nextInt( 100000 ) );
		}
		oStream.write( table.getSchema().getName() + "." +
			index.getName() + " ON " + table.getSchema().getName() +
			"." + table.getName() + " (" );
		writeColumnList( index.getColumns() );
		oStream.write( ") " );
		if ( index.getTablespace() != null ) {
			oStream.write( "TABLESPACE " + index.getTablespace() );
		}
		oStream.write( ";\n" );
		oStream.flush();
	}

	private void grantTablespace( String schema, String tablespace )
		 throws IOException {
		oStream.write( "ALTER USER " + schema +
			" QUOTA UNLIMITED ON " + tablespace + ";\n\n" );
		oStream.flush();
	}


	private void grantReferences( String schema, Table table )
		 throws IOException {
		oStream.write( "GRANT REFERENCES ON " + table.getSchema().getName() +
			"." + table.getName() + " TO " + schema + ";\n\n" );
		oStream.flush();
	}


	protected String getType( ColumnType type ) {
		if ( type == ColumnType.DATE ) {
			return "DATE";
		}
		else if ( type == ColumnType.STRING ) {
			return "VARCHAR2";
		}
		else if ( type == ColumnType.CLOB ) {
			return "CLOB";
		}
		else if ( type == ColumnType.CHARACTER ) {
			return "CHAR";
		}
		else if ( type == ColumnType.FLOAT ) {
			return "FLOAT";
		}
		else if ( type == ColumnType.NUMBER ) {
			return "NUMBER";
		}
		log.error( "Unable to get Oracle type: " + type.toString() );
		throw new RuntimeException( "Unable to get Oracle type: " + type.toString() );
	}

}

