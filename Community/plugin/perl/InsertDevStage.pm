#######################################################################
##           InsertDevStage.pm
##
##
#######################################################################

package GUS::Community::Plugin::InsertDevStage;
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;

use FileHandle;
use GUS::PluginMgr::Plugin;
use GUS::Model::SRes::DevelopmentalStage;
use GUS::Model::SRes::ExternalDatabaseRelease;
use GUS::Model::SRes::ExternalDatabase;

my $purposeBrief = <<PURPOSEBRIEF;
Loads Developmental Stages Terms into DB and creates hierarchy among them.
PURPOSEBRIEF

my $purpose = <<PLUGIN_PURPOSE;
This plugin load developmental stages terms from a file generated by DumpDevStage.  Developmental stages are organised into a graph and parent-child relationship are preserved.
PLUGIN_PURPOSE

my $tablesAffected =
	[['SRes.DevelopmentalStage', 'Developmenta stage terms are written here'],
	 ['SRes.ExternalDatabaseRelease', 'The user can optionally specify to create a new entry in this table when loading the developmental stages'],
	 ['SRes.ExternalDatabase', 'The user can optionally specify to create a new entry in this table when loading the developmental stages']];

my $tablesDependedOn = [ ];



my $argsDeclaration = [
		       fileArg({name => 'inputFile',
				descr => 'The file to be loaded',
				reqd => 1,
				constraintFunc => undef,
				isList => 0,
				mustExist => 1,
				format => 'see NOTES'
			    }),
		       
		       booleanArg({ name => 'createRelease',
				    descr => 'Set this to automatically create an external database release id for this version of the Developmental Stage file you are loading',
				    reqd => 0,
				    default => 0
				    })
		       
		       ];

my $howToRestart = <<PLUGIN_RESTART;
Restart the plugin.
PLUGIN_RESTART

my $failureCases = <<PLUGIN_FAILURE_CASES;
Unknown.
PLUGIN_FAILURE_CASES

my $notes = <<PLUGIN_NOTES;
The file format is hierarchy:source:definition, with hierarchy a semicolon delimited list of hierarchical IDs. The format is defined in the plugin GUS::Community::Plugin::Report::DumpDevStage.
PLUGIN_NOTES


my $documentation = {purposeBrief => $purposeBrief,
		     purpose => $purpose,
		     tablesAffected => $tablesAffected,
		     tablesDependedOn => $tablesDependedOn,
		     howToRestart => $howToRestart,
		     failureCases => $failureCases,
		     notes => $notes
		    };


################################################################
# new
################################################################
sub new {
    my ($class) = @_;
    my $self = {};
    bless($self, $class);
    
    $self->initialize(
		      {requiredDbVersion => 3.5,
		       cvsRevision =>  '$Revision: 5231 $', #CVS fills this in
		       name => ref($self),
		       argsDeclaration   => $argsDeclaration,
		       documentation     => $documentation,
		   });
    
    return $self;
}


################################################################
# run
################################################################
sub run {
    my ($self) = @_;
    
    my $n = $self->readFile($self->getArg('inputFile'));
    
    my $msg = "$n entries populated";
    return $msg;
}


sub readFile {
    my ($self, $fileName) = @_;
    
    open (FILE, "<$fileName"); 
    
    my @data = <FILE>;
    chomp @data;
    close(FILE);
    
    print "parsing data file...\n";
    
    my $ninserted = 0;
    
    foreach(@data) {
	my @cur = split(/\t/, $_);
	my @ids = split(/\;\;/, $cur[0]);
	
	my $taxonID    = $cur[1];
	my $source      = $cur[2];
	my $definition  = $cur[3];
	
	#print "currentID = [@ids] source=$source desc=$definition\n";
	
	my $currentID = $ids[$#ids];
	my $hierLevel = $#ids;
	
	$self->log("cur element = $currentID (her level = $hierLevel)");
	
        # test if this term is already in the db ?
	
	my $sql = "SELECT * FROM SRes.DevelopmentalStage WHERE NAME = '$currentID'";
	if($hierLevel != 0) {
	    for(my $i=1; $i<scalar @ids; $i++) {
		$sql = $sql." AND LEVEL_$i = '$ids[$i]'";
	    }
	}
	
	#print "**** Query = $sql\n";
	
	my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
	my ($result) = $sth->fetchrow_array();
	
	if(!defined $result) {
	    # not in the db, so populate the db
	    
	    # check if the immediate parent is in the db and get its id
	    my $parentID;
	    
	    if($#ids>0) {
		my $parentName = $ids[$#ids-1];
		my $parentHierLevel = $#ids-1;
		
		my $sql = "SELECT DEVELOPMENTAL_STAGE_ID FROM SRes.DevelopmentalStage WHERE NAME = '$parentName'";
		if($parentHierLevel>0) {
		    for(my $i=1; $i<scalar @ids-1; $i++) {
			$sql = $sql." AND LEVEL_$i = '$ids[$i]'";
		    }
		}
		
		#print "**** Parent Query = $sql\n";
		my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
		$parentID = $sth->fetchrow_array();
		
		if(!defined $parentID) {
		    die "parent '$parentName' of '$currentID' not in the database\n"; 
		}
	    }
	    
	    #populate entry
	    my $newDevStage = GUS::Model::SRes::DevelopmentalStage->new({
		'name'        => $currentID,
		'parent_ID'   => $parentID,
		'taxon_ID'    => $taxonID,
		'source'      => $source,
		'definition'  => $definition,
	    });
	    
	    if($hierLevel != 0) {
		for(my $i=1; $i<scalar @ids; $i++) {
		    my $attributeName = "level_$i";
		    $newDevStage->set($attributeName, '$ids[$i]');
		}
	    }
	    
	    $newDevStage->submit();
	    $ninserted++;
	}
	else {
	    $self->log("term $currentID already in DB\n");
	}
    }
    return $ninserted;
}


sub undoTables {
    my ($self) = @_;

    return ('SRes.DevelopmentalStage', 'SRes.ExternalDatabaseRelease', 'SRes.ExternalDatabase');
}
