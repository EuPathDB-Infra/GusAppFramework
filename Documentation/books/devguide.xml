<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
  <title>GUS Developer's Guide</title>

  <bookinfo>
    <date>$Date$</date>

    <releaseinfo>$Id: UsersGuide.xml,v 1.1.2.1 2005/05/05 20:18:59 msaffitz
    Exp $</releaseinfo>

    <legalnotice>
      <para>The Genomics Unified Schema and Application Framework are subject
      to various license terms and copyrights as outlined in the LICENSE file
      provided with the software.</para>
    </legalnotice>
  </bookinfo>

  <chapter>
    <title>The GUS Object Layer (Perl)</title>

    <sect1>
      <title>Description</title>

      <para>The GUS Perl object layer greatly simplifies loading data into a
      GUS database. It provides a Perl class (.pm file) for each table and
      view in GUS. Functionality includes:</para>

      <itemizedlist>
        <listitem>
          <para>Constructing new objects that can be written to the
          database.</para>
        </listitem>

        <listitem>
          <para>Retrieving objects from the database so that they can be
          updated</para>
        </listitem>

        <listitem>
          <para>Getting and setting attribute values on objects</para>
        </listitem>

        <listitem>
          <para>Managing parent-child relationships between objects. A
          "parent" is defined as the object representing a row that is pointed
          to by a foreign key. A "child" is defined as the object representing
          a row that contains the foreign key. A parent may have more than one
          type of child. A child may have more than one type of parent.</para>
        </listitem>

        <listitem>
          <para>Caching objects retrieved from the database so that only one
          object for any given row is present in memory at a time.</para>
        </listitem>

        <listitem>
          <para>Managing submits:</para>

          <itemizedlist>
            <listitem>
              <para>The type of submit (insert, update or delete) is
              automatically determined</para>
            </listitem>

            <listitem>
              <para>When a parent is submited all its children are
              automatically submitted, recursively.</para>
            </listitem>

            <listitem>
              <para>When a child is submitted, any parent that represents a
              new row in the database (does not yet have a primary key) is
              automatically submitted. A parent submitted this way, however,
              does not submit its children automatically (that could lead to
              cycles).</para>
            </listitem>

            <listitem>
              <para>When a tree of parent-child objects is submitted, the
              objects are all written as part of one transaction.</para>
            </listitem>

            <listitem>
              <para>If the type of submit is an update or a delete, the row
              modified in the database is copied to its table's version table.
              (This is default behavior but can be overridden)</para>
            </listitem>

            <listitem>
              <para>Relationships to DoTS.Evidence and DoTS.Similarity are
              managed automatically. In GUS, most relationships are
              represented by foreign keys. However some, called "weak
              relationships" are not. Instead of being constrained to point to
              one table only, weak relationships can point to any table.
              DoTS.Evidence and DoTS.Similarity offer those kind of
              relationships. The object layer detects relationships to them
              and correctly stores the weak relationship in the database. (See
              those tables in the GUS schema browser.)</para>
            </listitem>

            <listitem>
              <para>Automatically updates the GUS standard columns
              (row_user_id, row_alg_invocation_id, row_project_id,
              row_group_id and permissions).</para>
            </listitem>

            <listitem>
              <para>sequence_versions managed when new sequence string is
              set.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Outputting an object tree to a simple GUS XML format and
          parsing GUS XML into valid objects.</para>
        </listitem>

        <listitem>
          <para>Enforcing read/write permissions on retrieval of parents and
          children.</para>
        </listitem>

        <listitem>
          <para>Setting and getting DoTS.Evidence.</para>
        </listitem>

        <listitem>
          <para>Simple comparison operators to determine if an object matches
          a set of attributes or if an object has attributes that have been
          changed from the database.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1>
      <title>Object packages</title>

      <para>The GUS objects reside in a set of packages, depending on which
      schema they come from. The packages are:</para>

      <itemizedlist>
        <listitem>
          <para>GUS::Model::Core</para>
        </listitem>

        <listitem>
          <para>GUS::Model::DoTS</para>
        </listitem>

        <listitem>
          <para>GUS::Model::Prot</para>
        </listitem>

        <listitem>
          <para>GUS::Model::RAD</para>
        </listitem>

        <listitem>
          <para>GUS::Model::Study</para>
        </listitem>

        <listitem>
          <para>GUS::Model::SRes</para>
        </listitem>

        <listitem>
          <para>GUS::Model::TESS</para>
        </listitem>
      </itemizedlist>

      <para></para>
    </sect1>

    <sect1>
      <title>Object methods</title>

      <para>All GUS objects have methods to set and get attribute values,
      retrieve and submit the object and set parent-child relationships, among
      others. Taken together, these methods constitute the GUS Object Layer
      API. This section describes these methods.</para>

      <para><note>
          <para>The examples in this section use the GUS::Model::DoTS::Gene
          object and others. In your code you will use whatever objects are
          appropriate. To discover what objects are available, see the GUS
          Schema Browser available from the GUS website.</para>
        </note></para>

      <sect2>
        <title>Object constructor</title>

        <screen>my $gene = GUS::Model::DoTS::Gene-&gt;new($attributesHashRef)</screen>

        <para>This creates a Gene object. <code>$attributesHashRef</code> is a
        reference to a hash containing attribute values to set in the new
        object. The keys of the hash are the names of the attributes (i.e.,
        the column names in the GUS table), and the values of the hash are the
        values for those attributes. The hash may or may not contain key-value
        pairs for all the object's attributes.</para>

        <para>The object created does not yet have any connection to a row in
        the database. (see Retrieving Objects below and Submitting Objects
        below).</para>
      </sect2>

      <sect2>
        <title>Setting attribute values</title>

        <para>After an object is constructed, set an attribute value with the
        attribute's "setter" method. The object has a setter method for each
        column in its table. For example, to set a Gene's source Id,
        use:</para>

        <screen>$gene.setSourceId($sourceId)</screen>
      </sect2>

      <sect2>
        <title>Getting attribute values</title>

        <para>Each object has "getter" methods for each of its attributes. Use
        them like this:</para>

        <para><screen>my $sourceId = $gene.getSourceId()</screen></para>

        <para></para>

        <para></para>

        <para>Getting substrings from CLOB attribute types. This is
        particularly useful if one hasn't retrieved the CLOB attribute (see
        below) to save retrieving a very long sequence, for example, into
        memory. The method is a generic one to allow retrieving substrings
        from any CLOB attribute:</para>

        <screen>getSubstrFromClob($attribute,$start,$length) </screen>

        <note>
          <para>the start here is indexed from 1. To retrieve a sequence
          substring from a sequence object one would use <screen>$sequence-&gt;getSubstrFromClob('sequence',2334,1000)</screen>
          which would retrieve 1000 characters from the sequence attribute
          starting at position 2334.</para>
        </note>
      </sect2>

      <sect2>
        <title>Retrieving objects from the database</title>

        <para>Enough attributes must be set to ensure a single row is
        retrieved.</para>

        <screen>retrieveFromDB(\@attributesToNotRetrieve,$replaceCache)</screen>

        <para>Returns 1 if successful and populates the objects attribute
        values from the database. If unsuccessful returns 0 and leaves object
        unaffected. If multiple rows are returned then is considered
        unsuccessful. The query to the database simply constrains all the
        attributes that have been set. One can choose to NOT retrieve specific
        attributes by passing in an array reference of attribute names that
        should not be retrieved. This can be extremely useful for objects that
        have very large atts such as sequence if one only wants other
        attributes or just a substring from the sequence (see previous
        command).</para>
      </sect2>

      <sect2>
        <title>Managing Object Database Cache</title>

        <para>Objects are cached when retrieved from the database either with
        retrieveFromDB or getParent/Children methods. In the case of
        getParent/Children, if an object is requested that is already in the
        cache, the object in the cache is returned/added so that only a single
        object representing the tuple is present at any given time.
        RetrieveFromDB always retrieves the object from the database even if
        there is already a copy in the cache and replaces the current cached
        copy if the optional $replaceCache variable is used. Users should
        check the cache to see if an object already exists before retrieving
        from the db if there is a chance that they are constructing duplicate
        objects.<note>
            <para>The key of the cache is a concatenated string of the primary
            key values. This is generated by the method getConcatPrimKey(). In
            most cases (when there is a single primary key attribute) this
            will be just the value of the identifier returned by
            getId().</para>
          </note></para>

        <screen>addToDbCache($o,$replace)</screen>

        <para>adds objects to cache...this is done automatically when objects
        are retrieved from the database so shouldn't be called by
        users.</para>

        <screen>getFromDbCache($class,$key)</screen>

        <para>returns the object if it exists else undef.</para>

        <screen>isInDbCache($class,$key)</screen>

        <para>returns 1 if in the cache and undef otherwise. Note for testing
        purposes this is very similar to getFromDbCache.</para>

        <screen>removeFromDbCache($object)</screen>

        <para>removes the object ($object) from the dbCache.</para>
      </sect2>

      <sect2>
        <title>Setting default values</title>

        <para>These methods are used for setting default values which all
        subsequent objects created in the application will inherit. On submit
        these values will be set automatically.</para>

        <screen>setDefaultProjectId($project_id) (default = 0 (GUS))
getDefaultProjectId()
setDefaultUserId($id)
getDefaultUserId()
setDefaultGroupId($id)  (default = CBIL)
getDefaultGroupId()
setDefaultAlgoInvoId($id)
getDefaultAlgoInvoId()
setDefaultUserRead($read)  (default = 1)
getDefaultUserRead()
setDefaultUserWrite($val)  (default = 1)
getDefaultUserWrite()
setDefaultGroupRead($val)  (default = 1)
getDefaultGroupRead()
setDefaultGroupWrite($val)  (default = 1)
getDefaultGroupWrite()
setDefaultOtherRead($val)  (default = 1)
getDefaultOtherRead()
setDefaultOtherWrite($val)  (default = 0)
getDefaultOtherWrite()</screen>
      </sect2>

      <sect2>
        <title>Increasing the maximum number of objects allowed in RAM at one
        time (default is 10000)</title>

        <para>This method is necessary to prevent memory leaks due to
        forgetting to call undefPointerCache() in each loop to release objects
        for garbage collection. Unless the user needs more than 10000 objects
        at one time (which seems very unlikely) then these methods should be
        uneccessary.</para>

        <screen>setMaximumNumberOfObjects($num)
getMaximumNumberOfObjects()</screen>
      </sect2>

      <sect2>
        <title>Setting global NO version (default = 0)</title>

        <para>While this functionality defies the initial design of GUS, it is
        needed for dealing with things like draft sequence where one wants to
        simply wipe the database of the current version and replace it with
        something new. No objects are versioned.</para>

        <screen>setGlobalNoVersion($val)
getGlobalNoVersion()</screen>
      </sect2>

      <sect2>
        <title>Instance level management of versioning and updating</title>

        <para>Indvidual objects can be specified to be not versioned or not
        updateable. Default is to version and allow updates for all
        objects.</para>

        <screen>setVersionable($v) (default = 1)
isVersionable()
setUpdateable($u) (default = 1)
isUpdateable()</screen>
      </sect2>

      <sect2>
        <title>Checking read and write permissions</title>

        <para>Methods to check the read/write permissions based on the default
        group and user. Enforced when retrieving from database or retrieving
        children or parents.</para>

        <screen>checkReadPermission()
checkWritePermission()</screen>
      </sect2>

      <sect2>
        <title>Managing global behavior of objects (commit, verbose,
        debug)</title>

        <para>These parameters (once set) take affect on all objects.
        Defaults: commit = on, verbose = off, debug = off.</para>

        <screen>setDebuggingOn()</screen>

        <para>Reports debug statements for methods in RelationalRow.</para>

        <screen>setDebuggingOff()
getDebuggingState()</screen>

        <screen>setVerboseOn()</screen>

        <para>Turns on printing to stdout all SQL statements.</para>

        <screen>setVerboseOff()
getVerboseState()</screen>

        <screen>setCommitOff()</screen>

        <para>All submits will be rolled back rather than committed. Should
        not be turned off except for testing on a few loops.</para>

        <screen>setCommitOn()
getCommitState()</screen>
      </sect2>

      <sect2>
        <title>Managing memory (allowing garbage collection of objects that
        are out of scope)</title>

        <para>Necessary because of perls lack of a garbage collector that can
        deal with circular references. Only method really necessary as all
        others are automatically taken care of is undefPointerCache() which
        must be called in each loop. Note that this removes all objects from
        the pointer cache so all parent/child relationships are lost and must
        be re-established if needed.</para>

        <screen>removeAllChildPointers($recursive) </screen>

        <para>If $recursive = 1 then will call method on all children
        recursively.</para>

        <screen>addToPointerCache($ob)</screen>

        <para>Add objects to the pointer cache....done automatically when
        objects are created rarely if ever needs to be called.</para>

        <screen>getFromPointerCache($object_reference)</screen>

        <para>Method to retrieve the object from the pointer cache.</para>

        <screen>removeFromPointerCache($ob)</screen>

        <para>Removes single object from the cache.</para>

        <screen>undefPointerCache()</screen>

        <para>MUST be called in each loop to allow garbage collection. Removes
        all child and parent pointers so they can not be retrieved.</para>
      </sect2>

      <sect2>
        <title>Managing valid parents/children (code generator takes care of
        this)</title>

        <para>The objects keep a list of valid parents and children. Assuming
        the code generator is working correctly, these methods should not need
        to be used.</para>

        <screen>setChildList(@list)
addToChildList(@list)
getChildList()
isValidChild($c)
isOnChildList($className)
getChildSelfColumn($className)
getChildColumn($className)</screen>

        <para>@list is an array of array references
        [ChildTableName,My_primary_key,Childs_foreign_key_to_me]</para>

        <screen>setParentList(@list)
addToParentList(@list)
getParentList()
getParentSelfColumn($className)
getParentColumn($className)
isValidParent($p)
isOnParentList($className)</screen>

        <screen>set255ChildList(@list)
addTo255ChildList(@list)
get255ChildList()
get255ChildListPkAtt($className)
get255ChildListOrderAtt($className)
get255ChildListStringAtt($className)
isValid255ChildName($className)</screen>
      </sect2>

      <sect2>
        <title>Managing Children (objects with my primary key as a foreign
        key)</title>

        <para>Methods for managing children including retrieving from the
        database, getting (returning children) marking children deleted and
        submitting.<note>
            <para>Submitting children is automatically done whenever an object
            is submitted and should be unecessary (in fact the methods for
            managing the transaction may NOT work appropriately if one submits
            children manually). Submitting self results in submitting self and
            then all children within a single transaction.</para>
          </note></para>

        <para>getChildren or retrieveChildrenFromDB with one of the ImpClasses
        will bring back the appropriate subclass children/parent of that
        ImpClass. For example: getChildren('NAFeatureImp',1) will get any of
        the NAFeature subclass children such as RNAFeature, GeneFeature,
        ExonFeature etc. In this way, one can retrieve all the features
        associated with a given NASequence entry.</para>

        <screen>getChildren($className, $retrieveIfNoChildren, $getDeletedToo, $where,\@doNotRetrieveAttributes)</screen>

        <para>Returns an array of children in classname. If
        $retrieveIfNoChildren = 1 then it queries the DB for children of this
        class. If $retrieveIfNoChildren is not set to 1, then will only
        retrieve from the cache. If $getDeletedToo = 1 then will also return
        children that have been marked deleted. $where is a hash ref where
        children returned must meet all the attribute (key) =&gt; value
        (value) pairs in the hashref. If the $className is one of the "Imp"
        tables such as NASequenceImp, then the subclass objects of the correct
        type are returned....ie ExternalNASequence, Assembly as appropriate.
        The last argument is an array reference of attbibutes that should not
        be retrieved should these children need to be retrieved from the
        DB...ie $retrieveIfNoChildren = 1.</para>

        <screen>getAllChildren($retrieve, $getDeletedToo, $where) </screen>

        <para>Returns all children.</para>

        <screen>getChild($className, $retIfNochildren, $getDeletedToo)</screen>

        <para>Returns one child.<note>
            <para>This is only useful if you know there is only one child as
            returns the first one on the list if more than one.</para>
          </note></para>

        <screen>setChild($c)</screen>

        <para>Replaces children in this childs class with this child. Should
        use addChild for adding children.</para>

        <screen>retrieveChildrenFromDB($className, $resetIfHave, $where,\@doNotRetrieveAttributes )</screen>

        <para>Retrieves children in $className from the database. If
        $resetIfHave = 1 will reset any children that you already have to the
        values from the database. NOTE that any relationships established on
        the children that are reset will be lost. $where hash ref as for
        getChildren().<note>
            <para>Using getChildren($className,1) will call
            retrieveChildrenFromDB if they have not already been retrieved and
            so save a step.</para>
          </note></para>

        <screen>resetChildrenToDB($className, $where)</screen>

        <para>Removes all the children with this className and retrieves them
        fresh from the db.</para>

        <screen>retrieveAllChildrenFromDB($recursive, $resetIfHave)</screen>

        <para>Retrieves all this objects children. If $recursive = 1 will do
        this recursively.<note>
            <para>This has the potential for retrieving a huge number of
            objects if called from something like Group. $resetIfHave resets
            children you already have to the database.</para>
          </note></para>

        <screen>resetAllChildrenToDB()</screen>

        <para>Retrieves all children following removal of all existing
        ones.</para>

        <screen>addChild($c, $resetIfHave)</screen>

        <para>Method of choice for adding a child.</para>

        <screen>addChildren(@children)</screen>

        <para>Adds an array of children.</para>

        <screen>removeChild($c)</screen>

        <para>Remove child from self.<note>
            <para>This has NO impact on the database....simply removes pointer
            between parent and child.</para>
          </note></para>

        <screen>removeChildren(@ch)

removeChildrenInClass($className)

removeAllChildren()</screen>
      </sect2>

      <sect2>
        <title>Managing Parents</title>

        <para>Similar to managing children. Difference is that can only have
        one parent of each type.</para>

        <screen>setParent($p)</screen>

        <para>Sets this object as my parent. The parent likewise points to me
        as its child. Thus calling $p-&gt;addChild($self) is equivalent to
        $self-&gt;setParent($p)</para>

        <screen>getParent($className, $retrieveIfNoParent ,\@doNotRetrieveAttributes)</screen>

        <para>if $retrieveIfNoParent = 1 then calls retrieveParentFromDB if
        does not have that parent. If the $className is one of the "Imp"
        tables such as NASequenceImp, then the subclass objects of the correct
        type are returned....ie ExternalNASequence, Assembly as
        appropriate.</para>

        <screen>getAllParents($retrieveIfNoParent,\@doNotRetrieveAttributes )

retrieveParentFromDB($className ,\@doNotRetrieveAttributes)

retrieveAllParentsFromDB()</screen>

        <screen>setParentId($p) </screen>

        <para>Sets my foreign key to be the Id of this parent. Note that this
        occurs automatically upon submit to the database.</para>

        <screen>removeParent($p)

removeAllParents() </screen>
      </sect2>

      <sect2>
        <title>Managing submits to database</title>

        <para>Principal here is that the top level object (an object with only
        children) should be submitted. That object following submitting
        itself, will submit all its children recursively. Simple many-to-many
        relationships are traversed in order to set the foreign keys of the
        relation, however, the parent on the far side of the relation will not
        submit any of its children. All objects submitting with a single
        submit command are submitted in a single transaction so that if
        something fails, all are rolled back together to mantain database
        integrity. All tuples that are updated are versioned by default and
        sequences are stored (and versioned) appropriately. Evidence and
        Similarity facts are also submitted if they have been set (added).
        Upon delete, all Evidence and Similarity tuples that relate to the
        object are also deleted (and versioned of course!). Additionally,
        objects can store other objects to be submitted after they have
        submitted themselves and all their children via the method
        addToSubmitList($object).<note>
            <para>Submit and perhaps manage transaction are the only methods
            in this group that need to be called by user. The others are
            automatically taken care of appropriately.</para>
          </note></para>

        <screen>submit($notDeep, $noTran)</screen>

        <para>Automatically submits inside a transaction. $notDeep = 1 only
        submits self but not children. $noTran = 1 does not begin or (when
        finished) commit a transaction. Used by all children so are submitted
        in the initial objects transcation.</para>

        <screen>manageTransaction($noTran, $task)</screen>

        <para>This is dealt with automatically, However, if one wants to
        submit several top level objects in a single transaction, you can use
        manageTransaction to start and then commit a transaction and submit
        with noTran the objects in between. $task is either 'commit' or
        'begin'.</para>

        <screen>addToSubmitList($object)</screen>

        <para>Add $object to a submit list so that it gets submitted after I
        submit myself and all children (in the same transaction). This is the
        best way to submit objects on far side of a many-to-many relation that
        have children and thus need to be submitted explicitly.</para>

        <screen>setRollBack($rb)</screen>

        <para>This can be used during an update/submit to force a roll back at
        end of submit if errors are detected.</para>

        <screen>submitEvidence($e, $notDeep, $noTran)

submitAllEvidence($notDeep, $noTran)

deleteAllEvidence($notDeep, $noTran)

submitSimilarityFact($fact, $notDeep, $noTran)

submitAllSimilarityFacts($notDeep, $noTran)

deleteSimilarityFact($f, $notDeep, $noTran)</screen>

        <screen>deleteAllSimilarityFacts($notDeep, $noTran) </screen>

        <para>All similarity facts of an object are deleted upon submit if
        that object has been marked deleted.</para>

        <screen>submitAllChildren()

submitChildren()

submitChildrenInClass($className)

setAllForeignKeys()

allNonNullsSet()

version()

getVersionTableName()

getRollBack() </screen>

        <screen>setDefaultAttributes()</screen>

        <para>Sets all the attributes for which defaults have been set.</para>
      </sect2>

      <sect2>
        <title>Managing deletes</title>

        <para>Deletes occur in two phases. Objects must first be marked for
        deletion at wich time they can only be retrieved (with getChildren) if
        one adds in the bit to getDeletedToo. Objects are deleted from the
        database (and versioned) when submitted. Note that in order to delete
        a tuple, all it's foreign key relations (children) must also be marked
        deleted. The retrieveAllChildrenFromDB(1) and markDeleted(1) are
        recursive to facillitate this process.</para>

        <screen>markDeleted($doChildren)</screen>

        <para>Mark self deleted. It $doChildren = 1 then does this
        recursively.</para>

        <screen>isMarkedDeleted()</screen>

        <para>Returns 1 if object is marked deleted.</para>

        <screen>markUnDeleted()</screen>

        <screen>markChildDeleted($c)</screen>

        <para>Mark this child deleted so will be removed from the database on
        submit.</para>

        <screen>markChildrenInClassDeleted($className)</screen>

        <para>Mark all children in this class deleted.</para>

        <screen>markChildrenDeleted(@ch)</screen>

        <para>Mark each of these children deleted.</para>

        <screen>markAllChildrenDeleted($recursive)</screen>

        <para>Mark all the children I have deleted....recursively if
        $recursive = 1.</para>

        <screen>markChildUnDeleted($c)</screen>

        <para>Undelete child previously marked deleted.</para>

        <screen>markChildrenInClassUnDeleted($className)

markChildrenUnDeleted(@ch)

markAllChildrenUnDeleted()</screen>
      </sect2>

      <sect2>
        <title>Evidence</title>

        <para>Methods that allow setting and retrieving Evidence. Evidence
        gets submitting automatically by "target" object.</para>

        <screen>addEvidence($fact, $evidence_group_id, $attribute_name)</screen>

        <para>$fact is a fact object. Can optionally pass in an evidence group
        id to group relevant evidence such as for a gene model one might group
        the evidence for all the exons. Also optional is the attribute_name if
        the evidence is for a particular attribute of the target table such as
        "name" or "description".</para>

        <screen>getEvidence($factTableName, $retrieveUnlessHave)</screen>

        <para>This method returns an array of Evidence objects. One can
        retrieve the fact associated with each with
        EvidenceObj-&gt;getEvidenceFact(1);<note>
            <para>The optional argument 1 causes the fact object to be
            retrieved from the database if this has not already been
            done.</para>
          </note></para>

        <screen>getEvidenceByGroupId($factTableName, $retrieveUnlessHave)</screen>

        <para>method untested.</para>

        <screen>retrieveEvidenceFromDB($factTableName, $resetIfHave)</screen>

        <screen>retrieveAllEvidenceFromDB($resetIfHave, $targetOrFact)</screen>

        <para>Retrieves all the evidence for this object. It $targetOrFact
        then will retrieve whether this object is the target table or fact
        table. Default behaviour is to only retrieve evidence if target table.
        Use getEvidence then to return an array of evidence ojbects.</para>

        <screen>retrieveEvidenceFactsFromDB($evidence, $resetIfHave)

getAllEvidence()</screen>
      </sect2>

      <sect2>
        <title>Similarity facts for storing sequence similarities</title>

        <para>Methods for dealing with Similarity facts generated by blast and
        perhaps other sequence similarity algorithms.</para>

        <screen>addSimilarityFact($fact, $resetIfHave)

getSimilarityFacts($getIfDontHave)

retrieveSimilarityFactsFromDB($subjectTableName, $getEitherWay, $resetIfHave)</screen>
      </sect2>

      <sect2>
        <title>Methods for dealing with sequence</title>

        <para>Get, set, and format sequence.</para>

        <screen>getSequence()</screen>

        <para>Returns the sequence as single string.</para>

        <screen>setSequence($sequence)</screen>

        <para>Takes sequence string, cleans it up a bit (removes returns and
        non-sequence characters) and then sets.</para>

        <screen>getFeatureSequence()</screen>

        <para>All features support this method which retrieves the sequence
        corresponding to that feature. Basically retrieves a substring from
        the sequence to which the feature points corresponding to the span of
        the feature on the sequence. RNAFeature generates the sequence from
        the exons which make it up if it is predicted unless the actual
        sequence is stored in SplicedNASequence. NOTE that this method
        retrieves the sequence object to which it points without retrieving
        the sequence attribute. getSubstrFromClob is then used to extract the
        relevant substring, thus saving much memory in the case of very long
        sequences.</para>

        <screen>toFasta($type)</screen>

        <para>Returns fasta formatted sequence. If $type = 1 the id used is
        the na_sequence_id (or aa_sequence_id) otherwise it is the
        source_id.</para>
      </sect2>

      <sect2>
        <title>Printing</title>

        <para>Facility for printing to a string format or to XML. Returns a
        string that can be printed.</para>

        <screen>toString()</screen>

        <para>Returns in a simple string format the table object (does not
        indicate parent or child relationshps).</para>

        <screen>toXML($indent, $suppressDef, $doXmlIds, $family)</screen>

        <para>If $suppressDef = 1 then the default attributes below
        modification_date are suppressed. $doXmlIds = 1 will print XML ids in
        the object tags. $family = 1 will print parent/child relationships in
        object tags rather than nesting children (I think?).</para>
      </sect2>

      <sect2>
        <title>Parsing XML into objects</title>

        <screen>parseXML($xml)</screen>

        <para>Objects parse the xml themselves... $xml is an array reference
        where each line of the XML is an element.</para>

        <screen>processXmlAttributes($xml_atts)

getNextXmlId()

getXmlId()

setXmlId($id)

getObjectFromXmlId($xml_id) </screen>
      </sect2>

      <sect2>
        <title>Comparing attribute values</title>

        <para>An object can do simple checks given a hash reference
        (attributename =&gt; value) to see if all the values match ones in the
        object. Likewise, an object can take in an object with the same (or a
        subset of) atributes set and test for equivalence.</para>

        <screen>compareValues($v1, $v2, $type)</screen>

        <screen>testAttributeValues($href)</screen>

        <para>Test to see if all attribute =&gt; value pairs of the hash
        reference match my values.</para>

        <screen>testObjectAttributeValues($ob)</screen>

        <para>Self test to see if all attributes of $ob match values of self.
        Returns 1 if successful.</para>

        <screen>getAttributeDifferences($ob)</screen>

        <para>For comparing two objects...pass in the smaller object and $self
        will compare all attributes to see if values are same. Returns an
        array of attribute names that are different.</para>
      </sect2>

      <sect2>
        <title>Retrieving table ids and primary key attributes given
        name</title>

        <para>For getting the ids and table names from the Evidence and
        Similarity (mongo many to many) tables.</para>

        <screen>getTableNameHash()</screen>

        <screen>getTableNameFromTableId($table_id)</screen>

        <para>Returns the table name for $table_id.</para>

        <screen>getTableIdFromTableName($tableName)</screen>

        <para>Returns the table_id for $tableName.</para>

        <screen>getTablePKFromTableId($table_id)</screen>

        <para>Returns the primary key attribute for $table_id.</para>
      </sect2>

      <sect2>
        <title>General methods for dealing with facts</title>

        <para>Have NOT been tested and likely do not work...debug if you want
        to use!!</para>

        <screen>getFacts($factTableName)

getAllFacts()

addFact($fact)

submitFact($fact, $notDeep, $noTran)

submitAllFacts($notDeep, $noTran)</screen>
      </sect2>

      <sect2>
        <title>Miscellaneous methods</title>

        <screen>getClassName()</screen>

        <para>Returns class name (table name) of self.</para>

        <screen>getConcatPrimKey() </screen>

        <para>Returns the values of the primary key attributes concatentated
        into a string. Used by the dbCache as not all objects have a single
        attribute primary key.</para>

        <screen>haveAllPrimaryKeyValues()</screen>

        <screen>isValidAttribute($att)</screen>

        <para>Returns 1 if $att is a valid attribute of self.</para>

        <screen>getDatabase()</screen>

        <para>returns the DbiDatabase object from which one can get the extent
        and instance handles (and thus do queries) with the methods:
        getDbHandle() ##handle all objects use to interact with the DB.
        getMetaDbHandle() ##handle that retrieve meta information from
        DB.</para>

        <screen>getQueryHandle($autocommit)</screen>

        <para>Returns a Dbi database handle that does not interfere with the
        objects as may be the case with the above methods. If $autocommit is
        true, then the handle autocommits on submit to the db. You always get
        the same handle as it is cached so if you need yet another handle you
        can get it from DbiDatabase with:
        getDatabase()-&gt;makeNewHandle($autocommit)</para>

        <screen>getTotalUpdates()</screen>

        <para>Returns the total number of rows updated in this session.</para>

        <screen>getTotalInserts()</screen>

        <para>Returns the total number of rows inserted in this
        session.</para>

        <screen>getTotalDeletes()</screen>

        <para>Returns the total number of rows deleted in this session.</para>
      </sect2>

      <sect2>
        <title>Hand coded objects with extra functionality</title>

        <para>A number of the objects for GUS have been handcoded to have
        extra functionality. A couple of these have been mentioned earlier.
        For example, sequence objects (and all subclasses) have setSequence
        methods that clean up the sequence on submit. Also, all Feature
        objects have getFeatureSequence() methods.<note>
            <para>only a few are mentioned</para>
          </note></para>

        <sect3>
          <title>NASequence and all subclasses</title>

          <screen>setSequence($sequenceString)</screen>

          <para>Cleans up the sequence a bit before setting.</para>

          <screen>toFasta($type)</screen>

          <para>Returns the sequence in fasta format. It $type == 1, uses the
          source_id for the primary identifier, otherwise uses the
          na_sequence_id.</para>

          <screen>toCAML()</screen>

          <para>Returns the sequence entry in CAML format (from Paracel as
          input into CAP4).</para>
        </sect3>

        <sect3>
          <title>(NA|AA)Feature and all subclasses</title>

          <screen>getFeatureSequence()</screen>

          <para>Returns the sequence for the feature.</para>

          <screen>getFeatureLocation()</screen>

          <para>Gets the location of this feature as an array (startLocation,
          endLocation, is_reversed)</para>
        </sect3>

        <sect3>
          <title>Assembly and AssemblySequence</title>

          <para>These objects have many methods for manipulating assemblies
          and AssemblySequences from parsing cap2/cap4 output to
          reverseComplementing and generating cap2 alignments. Also has
          methods for computing/retrieving from the database putative SNPs.
          Only a few will be indicated here...users should look at the object
          (Objects/GUSdev/hand_edited/Assembly.pm) for more complete
          info.</para>

          <screen>Assembly-&gt;getCap2Alignment($idType,$suppressNumbers,$print)</screen>

          <para>Returns a cap2 format alignment for the assembly object.
          $idType if true uses source_ids for the assembly sequences rather
          than assembly_sequence_ids. if $suppressNumbers, does not print the
          locations on the right margin. If $print, prints to STDOUT the
          alignment as it is being generated....useful for very large
          assemblies as it starts printing very quickly.</para>

          <screen>Assembly-&gt;getRNA($retrieve,$getDeletedToo)</screen>

          <para>Returns the RNA associated with this assembly.</para>

          <screen>Assembly-&gt;ge tTranslatedAASequences($retrieve,$getDeletedToo)</screen>

          <para>Returns an array of TranslatedAASequences</para>
        </sect3>

        <sect3>
          <title>Similarity</title>

          <screen>setPValue($pValue)</screen>

          <para>Sets the pvalue given the actual pvalue (separates it into
          pvalue_mant and exp.</para>

          <screen>getPValue()</screen>

          <para>Returns the actual P Value.</para>

          <screen>generateSimilarityAlignment($type)</screen>

          <para>Returns an alignment for each HSP (SimilaritySpan) generated
          using $type algorithm where the algorithm is ([blast]|fasta|sim4)
          with blast being the default.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>DbiDatabase Methods: Establish logins, retrieve meta
        information</title>

        <para><emphasis role="bold">DbiDatabase is the module that is used to
        create logins to the database and from which all the other objects are
        generated.</emphasis> Thus, to start a session, you simply create a
        new DbiDatabase and you are then able to use all the objects
        representing specific tables in that database. DbiDatabase also has
        methods for getting meta information relevant to that database (such
        as getTables()) in addition to getTable(tableName) which returns a
        DbiTable for tableName. This enables users to access meta information
        for this specific table such as foreign key relationships, primary key
        attributes, etc. These methods, however, will in most cases be
        unecessary as the Table specific objects take care of all this for the
        user.</para>

        <screen>DbiDatabase-&gt;new( DBI_DSN, login,  password, verbose,  noInsert, default, dbName)</screen>

        <para>This creates a DbiDatabase that allows the use of all the
        following methods on specific objects. DBI_DSN is optional if you have
        your environment variable of this same name set. login, password, and
        dbname are required where dbname is case sensitive such as "GUSdev".
        Verbose if true prints all SQL statements executed and noInsert if
        true does not commit to the database although all sql is executed and
        then rolled back. The objects manage these attributes of the Database
        with setVerboseOn() and setCommitOff() (<xref
        linkend="globalBehavior" />).</para>

        <screen>DbiDatabase-&gt;logout()</screen>

        <para>Ends this session and disconnects all the handles
        generated.</para>

        <para>Additional methods are available if needed to retrieve meta
        information from the database such as a listing of all the
        tables/views etc.</para>
      </sect2>

      <sect2>
        <title></title>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <chapterinfo>
      <author>
        <surname>Fischer</surname>

        <firstname>Steve</firstname>

        <email>sfischer@pcbi.upenn.edu</email>
      </author>
    </chapterinfo>

    <title>Developing GUS Plugins</title>

    <sect1>
      <title>GUS Plugins</title>

      <para>GUS plugins are Perl programs that load data into GUS. They are
      written using the Plugin API (<xref linkend="pluginapi" />). You may use
      plugins that are bundled with the GUS distribution or you may write your
      own.</para>

      <para>The standard GUS practice is to use only plugins, not straight SQL
      or bulk loading, to load the database. The reason is that
      plugins:</para>

      <itemizedlist>
        <listitem>
          <para>track the data that is loaded</para>
        </listitem>

        <listitem>
          <para>copy any updated or deleted rows to "version" tables that
          store a history of the changes</para>
        </listitem>

        <listitem>
          <para>are known programs that can be scrutinized and used
          again</para>
        </listitem>

        <listitem>
          <para>have a standard documentation process so that they are easily
          understood</para>
        </listitem>

        <listitem>
          <para>use the Plugin API and so are easier to write than regular
          scripts.</para>
        </listitem>
      </itemizedlist>

      <sect2>
        <title>Supported versus Community Plugins</title>

        <para>The distribution of GUS comes with two types of
        plugins:<itemizedlist>
            <listitem>
              <para><emphasis>Supported</emphasis> plugins:<itemizedlist>
                  <listitem>
                    <para>are confirmed to work</para>
                  </listitem>

                  <listitem>
                    <para>are portable</para>
                  </listitem>

                  <listitem>
                    <para>are useful to sites other than the site that
                    developed the plugin</para>
                  </listitem>

                  <listitem>
                    <para>meet the Plugin Standard described below</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <para><emphasis>Community</emphasis> plugins:</para>

              <itemizedlist>
                <listitem>
                  <para>are contributed by the staff at CBIL and any other
                  plugin developers</para>
                </listitem>

                <listitem>
                  <para>have not been reviewed with respect to the criteria
                  for being supported</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>

        <para>When you begin writing your plugin, use as a guideline or as a
        template an existing supported plugin. They are found in
        <computeroutput>$PROJECT_HOME/GUS/Supported/plugin/perl</computeroutput>.</para>
      </sect2>

      <sect2>
        <title id="pluginapi">The Plugin API</title>

        <sect3>
          <title><computeroutput>Plugin.pm</computeroutput>: The Plugin
          Superclass</title>

          <para>GUS plugins are subclasses of
          <computeroutput>GUS::PluginMgr::Plugin</computeroutput>. The public
          subroutines in <computeroutput>Plugin.pm</computeroutput> (private
          ones begin with an underscore) constitute the Plugin API. GUS also
          provides Perl objects for each table and view in the GUS schema.
          These are also part of the API. (<xref
          linkend="pluginapi" />)</para>
        </sect3>

        <sect3>
          <title>The plugin's package and @ISA statements</title>

          <para>All plugins must declare their package, using Perl's
          <computeroutput>package</computeroutput> statement. The package name
          of a plugin is derived as follows:<screen><replaceable>ProjectName</replaceable>::<replaceable>ComponentName</replaceable>::<computeroutput>Plugin</computeroutput>::<replaceable>PluginName</replaceable></screen></para>

          <para>Plugins must also declare that they are subclasses of
          <computeroutput>Plugin.pm</computeroutput>, using Perl's
          <computeroutput>@ISA</computeroutput> array. The first lines of a
          plugin will look like this:<screen>package GUS::Supported::Plugin::SubmitRow

@ISA = qw(GUS::PluginMgr::Plugin)</screen></para>
        </sect3>

        <sect3>
          <title>Plugin Initialization</title>

          <para>Plugins are objects and so must have a constructor. This
          constructor is the <computeroutput>new()</computeroutput> method.
          The <computeroutput>new()</computeroutput> method has exactly two
          tasks to accomplish: constructing the object (and returning it), and
          initializing it. Construction of the object follows standard Perl
          practice. Initialization is handled by the
          <computeroutput>Plugin.pm</computeroutput> superclass method
          <computeroutput>initialize()</computeroutput>. <xref
          linkend="pluginapi" /> for details about that method.<example
              id="samplenew">
              <title>A Sample <computeroutput>new()</computeroutput>
              method</title>

              <screen>sub new {
    my ($class) = @_;
    my $self = {};

    bless($self,$class);

    $self-&gt;initialize({
        requiredDbVersion =&gt; 3.5,
        cvsRevision =&gt; '$Revision$',
        name =&gt; ref($self),
        argsDeclaration =&gt; $argsDeclaration,
        documentation =&gt; $documentation
    });

    return $self;
}</screen>
            </example></para>

          <para>The <computeroutput>$Revision$</computeroutput> string
          is CVS or Subversion keyword. When the plugin is checked into source
          control, the repository substitutes the file's revision into that
          keyword. The keywords must be in single quotes to prevent Perl from
          interpreting <computeroutput>$Revision$</computeroutput> as a
          variable.</para>
        </sect3>

        <sect3>
          <title>Keeping your Plugin Current as GUS Changes</title>

          <para>If you follow the pattern used by supported plugins, you will
          only ever need to change one line in the
          <computeroutput>new()</computeroutput> method. As you can probably
          tell, <computeroutput>initialize()</computeroutput> takes one
          argument, a reference to a hash that contains a set of parameter
          values. The one you will need to change is
          <computeroutput>requiredDbVersion</computeroutput>. As the GUS
          schema evolves, you will need to review your plugin to make sure it
          is compatible with the latest version of GUS, upgrading it if not.
          When it is compatible with the new version of GUS, update
          <computeroutput>requiredDbVersion</computeroutput> to that version
          of GUS.</para>
        </sect3>

        <sect3>
          <title id="pluginarg">Declaring the plugin's command line
          arguments</title>

          <para>In the example above (<xref linkend="samplenew" />), the
          line</para>

          <screen>argsDeclaration =&gt; $argsDeclaration,</screen>

          <para>provides to the
          <computeroutput>initialization()</computeroutput> method a reference
          to an array, <computeroutput>$argsDeclaration</computeroutput>, that
          declares what command line arguments the plugin will offer. When you
          look at a supported plugin you will see the
          <computeroutput>$argsDeclaration</computeroutput> variable being set
          like this:</para>

          <example>
            <title>Defining Command Line Arguments</title>

            <screen>my $argsDeclaration = [
   tableNameArg({name  =&gt; 'tablename',
                 descr =&gt; 'Table to submit to, eg, Core::UserInfo',
                 reqd  =&gt; 1,
                 constraintFunc=&gt; undef,
                 isList =&gt;0,
   }),

   stringArg({name  =&gt; 'attrlist',
              descr =&gt; 'List of attributes to update (comma delimited)',
              reqd  =&gt; 1,
              constraintFunc =&gt; undef,
              isList = &gt;1,
  }),

  enumArg({name  =&gt; 'type',
           descr =&gt; 'Dimension of attributes (comma delimited)',
           reqd  =&gt; 1,
           constraintFunc =&gt; undef,
           enum =&gt; "one, two, three",
           isList =&gt; 1,
  }),

  fileArg({name  =&gt; 'matrixFile',
           descr =&gt; 'File containing weight matrix',
           reqd =&gt; 1,
           constraintFunc=&gt; \&amp;checkFileFormat,
           mustExist=&gt;0,
           isList=&gt;0,
  }),
];</screen>
          </example>

          <para>If you look carefully at the list above you will notice that
          each element of it is a call to a method such as
          <computeroutput>stringArg()</computeroutput>. These are methods of
          <computeroutput>Plugin.pm</computeroutput> and they all return
          subclasses of
          <computeroutput>GUS::PluginMgr::Args::Arg</computeroutput>. In the
          case of <computeroutput>stringArg()</computeroutput>, it returns
          <computeroutput>GUS::PluginMgr::Args::StringArg</computeroutput>.
          All you really need to know is that there are a set of methods
          available for you to use when declaring your command line arguments.
          That is, the <computeroutput>argsDeclaration</computeroutput>
          parameter of the <computeroutput>initialize()</computeroutput>
          method expects a list of <computeroutput>Arg</computeroutput>
          objects. You can learn about them in detail in the Plugin API (<xref
          linkend="pluginapi" />)</para>

          <para>The <computeroutput>Arg</computeroutput> objects are very
          powerful. They parse the command line, validate the input, handle
          list values, deal with optional arguments and default values and
          provide for documentation of the arguments. There are two ways the
          <computeroutput>Arg</computeroutput> objects validate the input.
          First, it applies its standard validation. For example, a
          <computeroutput>FileArg</computeroutput> confirms that the input is
          a file, and throws an error otherwise. Second, if you provide a
          <computeroutput>constraintFunc</computeroutput>, it will run that as
          well, throwing an error if the plugin value violates the
          constraints.</para>
        </sect3>

        <sect3>
          <title id="plugindoc">Declaring the Plugin's Documentation</title>

          <para>In a way that parallels the declaration of command line
          arguments, the initialize method also expects a reference to a hash
          that provides standardized fields that document the plugin: (<xref
          linkend="samplenew" />)</para>

          <screen>documentation =&gt; $documentation,</screen>

          <para>Here is a code snippet that demonstrates the standard way
          <computeroutput>$documentation</computeroutput> is set:</para>

          <example>
            <title>Defining Plugin Documentation</title>

            <screen>my $purposeBrief = &lt;&lt;PURPOSE_BRIEF;
Load blast results from a condensed file format into the DoTS.Similarity table.
PURPOSE_BRIEF

my $purpose = &lt;&lt;PLUGIN_PURPOSE;
Load a set of BLAST similarities from a file in the form generated by the blastSimilarity command.
PLUGIN_PURPOSE

my $tablesAffected = 
    [ ['DoTS::Similarity', 'One row per similarity to a subject'],
      ['DoTS::SimilaritySpan', 'One row per similarity span (HSP)'],
    ];

my $tablesDependedOn =
    [
    ];

my $howToRestart = &lt;&lt;PLUGIN_RESTART;
Use the restartAlgInvs argument to provide a list of algorithm_invocation_ids that represent 
previous runs of loading these similarities. The algorithm_invocation_id of a run of this 
plugin is logged to stderr. If you don't have that information for a previous run or runs,  
you will have to poke around in the Core.AlgorithmInvocation table and others to find your 
runs and their algorithm_invocation_ids.
PLUGIN_RESTART

my $failureCases = &lt;&lt;PLUGIN_FAILURE_CASES;
PLUGIN_FAILURE_CASES

my $notes = &lt;&lt;PLUGIN_NOTES;
The definition lines of the sequences involved in the BLAST (both query and subject) must 
begin with the na_sequence_ids of those sequences. The standard way to achieve that is to
first load the sequences into GUS, using the InsertFastaSequences plugin, and then to 
extract them into a file with the dumpSequencesFromTable.pl command. That command places 
the na_sequence_id of the sequence as the first thing in the definition line.
PLUGIN_NOTES

my $documentation = { purpose=&gt;$purpose,
                      purposeBrief=&gt;$purposeBrief,
                      tablesAffected=&gt;$tablesAffected,
                      tablesDependedOn=&gt;$tablesDependedOn,
                      howToRestart=&gt;$howToRestart,
                      failureCases=&gt;$failureCases,
                      notes=&gt;$notes
                     };</screen>
          </example>

          <para>When you look at this example, you will see that a bunch of
          variables, such as <computeroutput>$purposeBrief</computeroutput>
          and <computeroutput>$tablesAffected</computeroutput>, are being set.
          They are used as values of the hash called
          <computeroutput>$documentation</computeroutput>.
          <computeroutput>$documentation</computeroutput> is in turn passed as
          a value to the <computeroutput>initialize()</computeroutput> method.
          You will also notice that Perl's HEREDOC syntax is used. The setting
          of the variables begins with, eg,
          <computeroutput>&lt;&lt;PLUGIN_PURPOSE</computeroutput> and ends
          with, eg, <computeroutput>PLUGIN_PURPOSE</computeroutput>. This is
          Perl's way of allowing you to create paragraph-style strings without
          worrying about quoting or metacharacters such as
          <computeroutput>\n</computeroutput>.</para>

          <para>The documentation is shown to the user when he or she uses the
          <computeroutput>help</computeroutput> flag, or when he or she makes
          a command line error.</para>

          <para>The documentation is formatted using Perl's documentation
          generation facility, pod. This means that you can include simple pod
          directives in your documentation to, say, emphasize a word. Run the
          command <computeroutput>perldoc perlpod</computeroutput> for more
          information</para>
        </sect3>

        <sect3>
          <title>The <computeroutput>run()</computeroutput>Method</title>

          <para>Plugins are run by a command called
          <computeroutput>ga</computeroutput> (which stands for "GUS
          application"). <computeroutput>ga</computeroutput> constructs the
          plugin (by calling its <computeroutput>new()</computeroutput>
          method) and then runs the plugin by calling its
          <computeroutput>run()</computeroutput> method.</para>

          <para>The purpose of the <computeroutput>run()</computeroutput>
          method is to provide at a glance the structure of the plugin. It
          should be very concise and under no circumstances be longer than one
          screen. A good practice, when reasonable, is for the
          <computeroutput>run()</computeroutput> method to call high level
          methods that return the objects to be submitted to the database, and
          then to submit them in the <computeroutput>run()</computeroutput>
          method. This way, a reader of the
          <computeroutput>run()</computeroutput> method will know just what is
          being written to the database, which is the main purpose of a
          plugin.</para>

          <para>The <computeroutput>run()</computeroutput> method is expected
          to return a string describing the result of running the plugin. An
          example would be "<computeroutput>inserted 3432
          sequences</computeroutput>".</para>
        </sect3>

        <sect3>
          <title>The Pointer Cache</title>

          <para>The pointer cache is a somewhat infamous component of the GUS
          object layer. It is a memory management facility that was designed
          to steer around poor garbage collection in Perl (in 2000). Whether
          or not is still needed is another matter because it is part of the
          object layer for now. The pointer cache is a way for the plugin to
          re-use objects that have been allocated but are no longer in active
          use. Because Perl was not properly garbage collecting objects when
          they were no longer referred to, the memory footprint of plugins was
          getting huge.</para>

          <para>As a plugin developer what you need to know is that at points
          in your code where you no longer need any of the GUS objects that
          you have created (typically at the bottom of your outermost loop,
          you should call the <computeroutput>Plugin.pm</computeroutput>
          method <computeroutput>undefPointerCache()</computeroutput>. This
          method clears out the cache.</para>

          <para>If the default capacity (10000) is not enough to hold all the
          objects you are creating in one cycle through your logic, you can
          augment its size with the <computeroutput>Plugin.pm</computeroutput>
          method
          <computeroutput>setPointerCacheSize()</computeroutput>.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>The Plugin Standard</title>

      <sect2>
        <title>Portability</title>

        <para>A supported plugin must be useful to sites other than the site
        that developed it. It also must run at other sites without
        modification.</para>
      </sect2>

      <sect2>
        <title>Plugin Naming</title>

        <itemizedlist>
          <listitem>
            <para>Plugin names begin with one of four verbs:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis>insert</emphasis> if the plugin inserts
                only</para>
              </listitem>

              <listitem>
                <para><emphasis>delete</emphasis> if the plugin deletes
                only</para>
              </listitem>

              <listitem>
                <para><emphasis>update</emphasis> if the plugin updates
                only</para>
              </listitem>

              <listitem>
                <para><emphasis>load</emphasis> if the plugin does any two or
                more of insert, delete or update</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Plugin names are concise</para>

            <itemizedlist>
              <listitem>
                <para>for example, a plugin named InsertNewSequences is not
                concise because Insert and New are redundant</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Plugin names are precise</para>

            <itemizedlist>
              <listitem>
                <para>for example, a plugin named InsertData is way too
                general. The name should reflect the type of data
                inserted</para>
              </listitem>

              <listitem>
                <para>if a Plugin expects exactly one file type, that file
                type should be in the name. For example,
                InsertFastaSequences.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Plugin names are accurate</para>

            <itemizedlist>
              <listitem>
                <para>for example, a plugin named InsertExternalSequences is
                inaccurate if it can also insert internally generated
                sequences. A better name would be InsertSequences.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </sect2>

      <sect2>
        <title>GUS Primary Keys</title>

        <para>Plugins never directly use (hard-code) GUS primary keys, either
        in the body of the code or for command line argument values. Instead
        they use semantically meaningful alternate keys. The reason that
        plugins cannot use primary keys in their code is that doing so makes
        the plugin site specific, not portable. The reason they cannot use
        primary keys as values in their command line arguments is that plugins
        are often incorporated as steps in a pipeline (using the GUS Pipeline
        API described elsewhere). The pipelines should be semantically
        transparent so that people both on site and externally who look at the
        pipeline will understand it.</para>
      </sect2>

      <sect2>
        <title>Application Specific Tables</title>

        <para>Some sites augment GUS with their own application specific
        tables. These are not permitted in supported plugins.</para>
      </sect2>

      <sect2>
        <title>Command Line Arguments</title>

        <itemizedlist>
          <listitem>
            <para>The name of the argument should be concise and
            precise</para>
          </listitem>

          <listitem>
            <para>The Plugin API provides a means for you to declare arguments
            of different types, such integers, strings and files (<xref
            linkend="pluginarg" />). Use the most appropriate type. For
            example, don't use a string for a file argument.</para>
          </listitem>

          <listitem>
            <para>Use camel caps (eg matrixFile) not underscores (eg
            matrix_file) in the names of the arguments.</para>
          </listitem>
        </itemizedlist>
      </sect2>

      <sect2>
        <title>Documentation</title>

        <para>The Plugin API provides a means for you to document the plugin
        and its arguments. Be thorough in your documentation. <xref
        linkend="plugindoc" /></para>
      </sect2>

      <sect2>
        <title>Use of GUS Objects</title>

        <para>The GUS object layer assists in writing clean plugin code. The
        guidelines for their use are:</para>

        <itemizedlist>
          <listitem>
            <para>When writing data to the database, use GUS objects when
            possible. Avoid using SQL directly.</para>
          </listitem>

          <listitem>
            <para>When forming a relationship between two objects, use the
            <computeroutput>setParent()</computeroutput> or
            <computeroutput>setChildren()</computeroutput> method. Do not
            explicitly set the foreign keys of the objects.</para>
          </listitem>
        </itemizedlist>
      </sect2>

      <sect2>
        <title>Database Access</title>

        <para>The GUS objects are good at writing data to the database. That
        is because they allow you to build up a tree structure of objects and
        then to simply submit the root. However they are not as useful at
        reading the database. You can only read one object at a time (more on
        this in the Guide to GUS Objects). For this reason, you will need to
        use SQL to efficiently read data from the database as needed by your
        plugin.</para>

        <para>This is how a typical database access looks:</para>

        <example>
          <title>Typical Database Access</title>

          <screen>my $sql = 
  "SELECT $self-&gt;{primaryKeyColumn}, $self-&gt;{termColumn} 
   FROM $self-&gt;{table}";

my $queryHandle = $self-&gt;getQueryHandle();
my $statementHandle = $queryHandle-&gt;prepareAndExecute($sql);

my %vocabFromDb;

while (my ($primaryKey, $term) = $sth-&gt;fetchrow_array()) {
    $vocabFromDb{$term} = $primaryKey;
}</screen>
        </example>

        <para>The SQL is formatted on multiple lines for clarity (Perl allows
        this), and the SQL keywords are upper case. The Plugin API provides a
        method to easily get a query handle, returning a
        <computeroutput>GUS::ObjRelP::DbiDbHandle</computeroutput>. That
        object provides an easy-to-use method that prepares and executes the
        SQL.</para>
      </sect2>

      <sect2>
        <title>Logging</title>

        <para>The Plugin API offers a set of logging methods. They print to
        standard error. Use these and no other means of writing out logging
        messages.</para>
      </sect2>

      <sect2>
        <title>Standard Output</title>

        <para>Do not write to standard output. If your plugin generates data
        (such as a list of IDs already loaded, for restart) write it to a
        file.</para>
      </sect2>

      <sect2>
        <title>Commenting</title>

        <para>Less is more with commenting. Comment only the non-obvious. For
        example, do not comment a method called
        <computeroutput>getSize()</computeroutput> with a comment
        <computeroutput># gets the size</computeroutput>. Most methods should
        need no commenting, as they should be self-explanatory. In many cases,
        if you find that you need to comment because something non-obvious
        needs explaining, that is a red flag indicating that your code might
        need simplification.</para>
      </sect2>

      <sect2>
        <title>Handling Errors</title>

        <para>There is only one permissible way to handle errors: call
        <computeroutput>die()</computeroutput>. Never log errors or write them
        to standard error or standard out. Doing that masks the error (the
        logs are not read reliably) so that what is really happening is the
        plugin is failing silently. Causing the plugin to die forces the user
        of the plugin or its developer to fix the problem.</para>

        <para>When you call die, give it an informative message, including the
        values of the suspicious variables. Surround the variables in single
        quotes so that white space errors will be apparent. Provide enough
        information so that the user can track down the source of the problem
        in the input files.</para>

        <para>If you would like your program to continue past errors, then
        dedicate a file or directory which will house describing the errors.
        The user will know that he or she must look there for a list of inputs
        that caused problems. Typically you use this strategy if you expect
        the input to be huge, and don't want to abort it because of a few
        errors. You may want to include as a command line argument the number
        of errors a user will tolerate before giving up and just
        aborting.</para>
      </sect2>

      <sect2>
        <title>Failure Recovery and Restart</title>

        <para>Plugins abort. They do so for many reasons. When they do, the
        user must be able to recover from the failure, one way or
        another.</para>

        <para>A few strategies you could adopt are:<itemizedlist>
            <listitem>
              <para>If the plugin is inserting data (rather than inserting and
              updating) the plugin can check if an object that is about to be
              written to the database is already there. If so, it can skip
              that object. Because this checking will slow the plugin down,
              the plugin should offer a
              <computeroutput>restart</computeroutput> flag on the command
              line that turns that check on.</para>
            </listitem>

            <listitem>
              <para>If the plugin is updating it can include a command line
              argument that takes a list of
              <computeroutput>row_alg_invocation_id</computeroutput>s, one per
              each run of the plugin with this dataset. (Each table in GUS has
              a <computeroutput>row_alg_invocation_id</computeroutput> column
              to store the identifier of the particular run of a plugin that
              put data there. This is part of the automatic tracking that
              plugins do.) The plugin can take the same approach as the
              previous strategy, but, must additionally check that the object
              has one of the provided
              <computeroutput>row_alg_invocation_id</computeroutput>s.</para>
            </listitem>

            <listitem>
              <para>The plugin can store in dedicated file the identifiers of
              the objects it has already loaded. In this case, the plugin
              should offer a command line argument to ask for the name of the
              file.</para>
            </listitem>
          </itemizedlist></para>
      </sect2>

      <sect2>
        <title>Opening Files</title>

        <para>A very common error is to open files without dying if the open
        fails. The proper way to open a file is like this:</para>

        <example>
          <title>Properly Opening a File</title>

          <screen>open(FILE, $myFile) || die "could not open file '$myFile'\n");</screen>
        </example>
      </sect2>

      <sect2>
        <title>Caching to Minimize Database Access</title>

        <para>One of the most time consuming operations in a plugin is
        accessing the database. The typical flow of a plugin is that it reads
        the input and as it goes it constructs and submits GUS objects to the
        database. Some plugins additionally need to read data from the
        database to do their work. While it is often impossible to avoid
        writing to the database with each new input value, it is often
        possible to avoid reading it.</para>

        <para>If most of the values of a table (or tables) will be needed then
        the plugin should read the table (or tables) outside the loop that
        processes the input. It should store the values in a hash keyed on a
        primary or alternate key. Storing multiple megabytes of data this way
        in memory should not be a problem. Gigabytes may well be a
        problem.</para>

        <para>If only a few values from the table will be needed then an
        alternative caching strategy may be appropriate. Wrap the access to
        the values in a getter method, such as
        <computeroutput>getGeneType()</computeroutput>. This method stores
        values it gets in a hash. When the method is called, it first looks in
        the hash for the value. If the hash does not have it, then the method
        reads the database and stores the value in the hash to optimize future
        accesses.</para>
      </sect2>

      <sect2>
        <title>Regular Expressions</title>

        <para>Complicated regular expressions should be accompanied by a
        comment line that shows what the input string looks like. It is
        otherwise often very difficult to figure out what the regular
        expression is doing. Long regular expressions should be split into
        multiple lines with embedded whitespace and comments using the
        <computeroutput>/x</computeroutput> modifier. See the "Readability"
        section of <ulink
        url="http://www.perl.com/pub/a/2004/01/16/regexps.html">Maintaining
        Regular Expressions</ulink></para>
      </sect2>

      <sect2>
        <title>Variable and Method Names</title>

        <para>Choosing good names for your variables and methods makes your
        code much more understandable. To make your code clear:<itemizedlist>
            <listitem>
              <para>Variable and method names should start with a lower case
              letter.</para>
            </listitem>

            <listitem>
              <para>Use "camel caps"
              (<computeroutput>$sequenceLength</computeroutput>) for variable
              names and method names, not underscores
              (<computeroutput>$sequence_length</computeroutput>).</para>
            </listitem>

            <listitem>
              <para>Variable names should be named after the type of data they
              hold (unless there are more than one variable for a given type,
              in which case they are qualified). For example a good name for a
              sequence would be
              <computeroutput>$sequence</computeroutput></para>
            </listitem>

            <listitem>
              <para>In plugins, there are typically:</para>

              <itemizedlist>
                <listitem>
                  <para>strings parsed from the input</para>
                </listitem>

                <listitem>
                  <para>objects created from the input (if you are using an
                  object based parser such as Bioperl)</para>
                </listitem>

                <listitem>
                  <para>GUS object layer objects</para>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>Input objects or strings should be named with 'input' as a
              prefix. For example:
              <computeroutput>$inputSequence</computeroutput></para>
            </listitem>

            <listitem>
              <para>Object layer objects are named for their type, for example
              <computeroutput>$NASequence</computeroutput></para>
            </listitem>

            <listitem>
              <para>Method names should be self-explanatory. A bad method name
              would be <computeroutput>process()</computeroutput> (what is
              being processed?). Don't "save keystrokes" with short names. If
              being self-explanatory requires using a long name, then use a
              long name.</para>
            </listitem>
          </itemizedlist></para>
      </sect2>

      <sect2>
        <title>Methods</title>

        <para>Use "structured programming" when you create your
        methods:<itemizedlist>
            <listitem>
              <para>No method should ever be longer than one screen. If it is,
              refactor part of into its own method.</para>
            </listitem>

            <listitem>
              <para>Never repeat code. Repeated code must be in a
              method.</para>
            </listitem>
          </itemizedlist></para>

        <para>Some methods in the API are marked as deprecated. Do not use
        them. They are for backward compatibility only.</para>
      </sect2>

      <sect2>
        <title>Syntax</title>

        <itemizedlist>
          <listitem>
            <para>Use C and Java like syntax. Do not use weird Perl specific
            syntax.</para>
          </listitem>

          <listitem>
            <para>Indenting must be spaces not tabs. Two or four spaces are
            acceptable</para>
          </listitem>

          <listitem>
            <para>Use <computeroutput>$self</computeroutput> to refer to the
            object itself</para>
          </listitem>

          <listitem>
            <para>Declare method arguments using this syntax: <screen>my ($self, $sequence, $length) = @_;.</screen>Do
            not use <computeroutput>shift</computeroutput></para>
          </listitem>
        </itemizedlist>
      </sect2>

      <sect2>
        <title>Application Specific Controlled Vocabularies</title>

        <para>A controlled vocabulary (CV) is a restricted set of terms that
        are allowed values for a data type. They may be simple lists or they
        may be complex trees, graphs or ontologies. In GUS the CVs fall into
        two categories: standard CVs such as the Gene Ontology, and small
        application specific CVs such as ReviewStatus.</para>

        <para>The complete list of application specific CVs in the GUS 3.5
        schema is:<itemizedlist>
            <listitem>
              <para>DoTS.BlatAlignmentQuality</para>
            </listitem>

            <listitem>
              <para>DoTS.GOAssociationInstanceLOE</para>
            </listitem>

            <listitem>
              <para>DoTS.GeneInstanceCategory</para>
            </listitem>

            <listitem>
              <para>DoTS.InteractionType</para>
            </listitem>

            <listitem>
              <para>DoTS.MotifRejectionReason</para>
            </listitem>

            <listitem>
              <para>DoTS.ProteinCategory</para>
            </listitem>

            <listitem>
              <para>DoTS.ProteinInstanceCategory</para>
            </listitem>

            <listitem>
              <para>DoTS.ProteinProteinCategory</para>
            </listitem>

            <listitem>
              <para>DoTS.ProteinPropertyType</para>
            </listitem>

            <listitem>
              <para>DoTS.RNACategory</para>
            </listitem>

            <listitem>
              <para>DoTS.RNAInstanceCategory</para>
            </listitem>

            <listitem>
              <para>DoTS.RNARNACategory</para>
            </listitem>

            <listitem>
              <para>DoTS.RepeatType</para>
            </listitem>

            <listitem>
              <para>SRes.BibRefType</para>
            </listitem>

            <listitem>
              <para>SRes.ReviewStatus</para>
            </listitem>
          </itemizedlist></para>

        <para>Acquiring a standard CV typically involves downloading files
        from the CV provider and running a plugin to load it.</para>

        <para>Application specific CVs are handled by the plugin that will use
        the CV. For example, a plugin that inserts bibliographic references
        will use the SRes.BibRefType CV. It is these plugins that are
        responsible for making sure that the CV they want to use is in the
        database.</para>

        <para>Plugins that use CVs fall into two categories:<orderedlist>
            <listitem>
              <para>those that hard code the CV</para>
            </listitem>

            <listitem>
              <para>those that do not hard code the CV, but, rather, get it
              from the input</para>
            </listitem>
          </orderedlist></para>

        <para>In case 1, the plugin hard codes the CV in the Perl code.</para>

        <para>In case 2, the plugin hard codes only a default. It also offers
        an optional command line argument that takes a file that contains the
        CV. If the user of the plugin determines that the input has an
        different CV than the default, the user will provide such a
        file.</para>

        <para>In both cases, the plugin reads the table in GUS that contains
        the CV and compares it to the CV it expects to use. If the expected
        vocab is not found, the plugin updates the table.</para>
      </sect2>

      <sect2>
        <title>Assigning an External Database Release Id</title>

        <para>GUS is a data warehouse so it is very common for plugins to load
        into GUS data from another source. Whether the source is external or
        in-house, tracking its origin is often required. The tables in GUS
        that handle this are SRes.ExternalDatabase and
        SRes.ExternalDatabaseRelease. The former describes the database, eg,
        PFam, and the latter describes the particular release of the database
        that is being loaded, eg, 1.0.0. The data loaded will have a foreign
        key to the database release, which in turn has a foreign key to the
        database.</para>

        <para>In order to create that relationship, the plugin must know the
        primary key of the external database release. To accomplish this, the
        plugin takes as command line arguments the name of the database and
        its release. It does not take the primary key of the external database
        release (that violates the plugin standard). The plugin passes that
        information to the API subroutine
        <computeroutput>getExtDbRlsId($dbName,
        $dbVersion)</computeroutput>.</para>

        <para>If the plugin is inserting the dataset as opposed to updating
        it, create new entries for the database and the release by using the
        plugins
        <computeroutput>GUS::Supported::Plugin::InsertExternalDatabase</computeroutput>
        and
        <computeroutput>GUS::Supported::Plugin::InsertExternalDatabaseRls</computeroutput>.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <chapterinfo>
      <author>
        <surname>Saffitz</surname>

        <firstname>Michael</firstname>

        <email>msaffitz@pcbi.upenn.edu</email>
      </author>
    </chapterinfo>

    <title>Extending the Schema</title>

    <para>The GUS Schema may be extended by adding new columns to existing
    tables, or adding new tables and views. For the time being, adding new
    Schemata to GUS is not supported.<important>
        <para>Extensions to the GUS may interfere with your ability to upgrade
        to future releases of GUS.</para>
      </important></para>

    <sect1>
      <title>Creating New Objects in the Database</title>

      <para>The first step to extending the Schema is to create the objects
      within the database.</para>

      <sect2>
        <title>Adding New Columns to Existing Tables</title>

        <para>When adding new columns to existing tables, it is important to
        maintain the existing order of the columns, and only add new columns
        between the existing columns and the housekeeping columns (eg before
        the <computeroutput>modification_date</computeroutput> column). For
        this reason, it will likely be necessary to rename the existing table;
        create the modified table; and then migrate the date from the existing
        table to the newly created table. As you perform this process, you
        should ensure that all constraints (including both "incoming" and
        "outgoing" foreign key constraints and primary key constraints) and
        that indexes on the original table are created and applied on the
        newly created table.</para>
      </sect2>

      <sect2>
        <title>Adding New Tables</title>

        <para>When creating new tables, it is important to include all
        housekeeping columns at the "end" of the definition in the proper
        order. All new tables should have a corresponding sequence created,
        with the naming convention of:
        <computeroutput><replaceable>TableSchemaName</replaceable>.<replaceable>TableName</replaceable>_SQ</computeroutput>
        . All new tables must have a single column primary key constraint
        defined.</para>
      </sect2>

      <sect2>
        <title>Adding New Views</title>

        <para>Only views created as "subclass" views against an implementation
        table are supported. When creating new views, it is important to
        include all superclass columns in the view definition, including the
        housekeeping columns. Proper column ordering should be observed in the
        views.</para>
      </sect2>

      <sect2>
        <title>Updating GUS Version Objects</title>

        <para>If you've changed an existing GUS table, or wish to have GUS
        audit changes to your new tables and views, you must make the
        corresponding changes and/or additions to the version ("ver") tables
        and views.</para>
      </sect2>

      <sect2>
        <title>Updating
        <computeroutput>Core.TableInfo</computeroutput></title>

        <para>GUS stores metadata for all tables and views in the
        <computeroutput>Core.TableInfo</computeroutput> table. Whenever you
        create a new table or view, you must add a corresponding row in this
        table. The column descriptions are:<table>
            <title><computeroutput>Core.TableInfo</computeroutput>
            Description</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Column Name</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><computeroutput>table_id</computeroutput></entry>

                  <entry>The ID of this row, provided by the
                  <computeroutput>com Core.TableInfo_SQ</computeroutput>
                  sequence.</entry>
                </row>

                <row>
                  <entry><computeroutput>name</computeroutput></entry>

                  <entry>The name of the table. The case used here will be
                  used at object-generation time.</entry>
                </row>

                <row>
                  <entry><computeroutput>table_type</computeroutput></entry>

                  <entry><computeroutput>Standard</computeroutput> or
                  <computeroutput>Version</computeroutput>, depending on
                  whether this is a normal table or a version table</entry>
                </row>

                <row>
                  <entry><computeroutput>primary_key_column</computeroutput></entry>

                  <entry>The name of the primary key column</entry>
                </row>

                <row>
                  <entry><computeroutput>database_id</computeroutput></entry>

                  <entry>The id of the schema, found in
                  <computeroutput>Core.DatabaseInfo</computeroutput></entry>
                </row>

                <row>
                  <entry><computeroutput>is_versioned</computeroutput></entry>

                  <entry>1 if the table has a corresponding version table. 0
                  otherwise.</entry>
                </row>

                <row>
                  <entry><computeroutput>is_view</computeroutput></entry>

                  <entry>1 if the "table" is a subclass view. 0
                  otherwise.</entry>
                </row>

                <row>
                  <entry><computeroutput>view_on_table_id</computeroutput></entry>

                  <entry>If this "table" is a subclass view, the table id of
                  the implementation table that this view is against.</entry>
                </row>

                <row>
                  <entry><computeroutput>superclass_table_id</computeroutput></entry>

                  <entry>If this "table" is a subclass view, the table id of
                  the superclass view.</entry>
                </row>

                <row>
                  <entry><computeroutput>is_updatable</computeroutput></entry>

                  <entry>1 if the table is read/write, 0 if it is read
                  only.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </sect2>

      <sect2>
        <title>Applying Permission</title>

        <para>After you have created the new objects in the RDBMS, but before
        rebuilding the objects, you must be sure to grant the proper
        permissions (select, update, insert, delete) to anyone that will be
        using GUS. Otherwise, the rebuild process will fail.</para>
      </sect2>

      <sect2>
        <title>Rebuilding Objects</title>

        <para>After you have completed the steps above, you must rebuild your
        objects. First, use the command below to signal that your table
        definitions have changed:<screen>$ touch $PROJECT_HOME/Schema/gus_schema.xml</screen></para>

        <para>Then, reinstall GUS:<screen>$ build GUS install -append</screen></para>
      </sect2>
    </sect1>
  </chapter>
</book>