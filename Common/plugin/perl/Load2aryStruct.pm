package GUS::Common::Plugin::Load2aryStruct;
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;
use GUS::PluginMgr::Plugin;
use GUS::Model::DoTS::SecondaryStructure;
use GUS::Model::DoTS::SecondaryStructureCall;
use GUS::Model::Core::DatabaseInfo;
use GUS::Model::Core::TableInfo;
use FileHandle;

sub new {
  my ($class) = @_;
  my $self = {};
  bless($self,$class);

  my $purposeBrief = "Load SAGE tag-count pairs from a file.";

  my $purpose = <<PLUGIN_PURPOSE;
This plugin loads protein secondary structure predictions generated by PSIPRED.
Each run loads data for one protein, creating one record in
DoTS.SecondaryStructure, and one record per type of secondary structure in
DoTS.SecondaryStructureCall.  Typically there are three types of secondary
structure: helix, turn and coil.
PLUGIN_PURPOSE

  my $tablesAffected =
    [ ['DoTS::SecondaryStructure', 'Insert one record'],
      ['DoTS::SecondaryStructureCall', 'Insert one record per structure type'],
    ];

  my $tablesDependedOn =
    [ ['Core::DatabaseInfo', 'Look up table IDs by database/table names'],
      ['Core::TableInfo', 'Look up table IDs by database/table names'],
    ];

  my $howToRestart = <<PLUGIN_RESTART;
This plugin has no restart facility.
PLUGIN_RESTART

  my $failureCases = <<PLUGIN_FAILURE_CASES;
PLUGIN_FAILURE_CASES

  my $notes = <<PLUGIN_NOTES;
PLUGIN_NOTES

  my $documentation = { purpose=>$purpose,
                        purposeBrief=>$purposeBrief,
                        tablesAffected=>$tablesAffected,
                        tablesDependedOn=>$tablesDependedOn,
                        howToRestart=>$howToRestart,
                        failureCases=>$failureCases,
                        notes=>$notes
                      };

  my $argsDeclaration =
    [
     integerArg({name  => 'aa_sequence_id',
		 descr => 'aa_sequence_id',
		 reqd  => 1,
		 constraintFunc=> undef,
		 isList=> 0,
		}),
     integerArg({name  => 'pred_alg_invocation_id',
		 descr => 'pred_alg_invocation_id',
		 reqd  => 1,
		 constraintFunc=> undef,
		 isList=> 0,
		}),
     stringArg({name  => 'datafile',
		 descr => 'datafile',
		 reqd  => 1,
		 constraintFunc=> undef,
		 isList=> 0,
		}),
    ];


  $self->initialize({requiredDbVersion => {},
                     cvsRevision => '$Revision$', # cvs fills this in!
                     cvsTag => '$Name$', # cvs fills this in!
                     name => ref($self),
                     revisionNotes => 'make consistent with GUS 3.0',
                     argsDeclaration => $argsDeclaration,
                     documentation => $documentation
                    });
  return $self;
}

sub run {
  my ($self) = @_;
  $self->logAlgInvocationId;
  $self->logCommit;

  $self->loadStructureFile($self->getArg('datafile'),
		           $self->getArg('aa_sequence_id'),
			   $self->getArg('pred_alg_invocation_id'));

  $self->logVerbose("Finished Load2aryStruct.");
}

# ----------------------------------------------------------------------
# Given the name of a data file, read tag-count pairs from it
# and add them to RAD

sub loadStructureFile {
  my ($self, $datafile, $aa_sequence_id, $pred_alg_invocation_id) = @_;

  my $fh = FileHandle->new('<'.$datafile);
  if (! $fh) {
    die ("Can't open datafile $datafile");
  }

  my ($cCalls, $hCalls, $eCalls);

  while (<$fh>) {
    chomp;

    $cCalls .= substr($_, 13,1);
    $hCalls .= substr($_, 20,1);
    $eCalls .= substr($_, 27,1);
  }
  $fh->close();

  # print "C calls: $cCalls\n";
  # print "H calls: $hCalls\n";
  # print "E calls: $eCalls\n";

  my $secondaryStructure = GUS::Model::DoTS::SecondaryStructure->new
    ( {
       aa_sequence_id => $aa_sequence_id,
       pred_alg_invocation_id => $pred_alg_invocation_id,
      } );

  $secondaryStructure->retrieveFromDB();

  my $eCall = GUS::Model::DoTS::SecondaryStructureCall->new
    ( {
       structure_type => 'E'
      } );

  $eCall->setCallConfidence($eCalls);
  $eCall->setParent($secondaryStructure);

}
