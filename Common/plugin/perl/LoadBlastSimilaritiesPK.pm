package GUS::Common::Plugin::LoadBlastSimilaritiesPK;

@ISA = qw(GUS::PluginMgr::Plugin); 
use strict;

use GUS::Common::BulkSimilarity;

sub new {
  my ($class) = @_;
  my $self = {};
  bless($self,$class);

  my $usage = 'Load in blast similarities generated by generateBlastSimilarity.pl  NOTE: Both query and subject must use primary key as identifier';

  my $easycsp =
    [{o => 'subject_table',
      t => 'string',
      h => 'subjects are taken from this table (schema::table format).',
     },
     {o => 'log_frequency',
  

    t => 'int',
      h => 'Write line to log file once every this many entries',
      d => 10,
     },
     {o => 'query_table',
      t => 'string',
      h => 'queries are taken from this table (schema::table format). ',
     },
     {o => 'files',
      t => 'string',
      h => 'read condensed results from this file',
      l => 1,
     },
     {o => 'nqueries',
      t => 'int',
      h => 'process this many queries',
      d => 1e6,
     },
     {o => 'output',
      t => 'string',
      h => 'what type of similarity children to put in db',
      d => 'both',
      e => [ qw ( both summaries spans ) ],
     },
     {o => 'restart',
      t => 'string',
      h => 'restarts from last entry in Similarity.... takes list of row_alg_invocation_ids "234, 235"!',
     },
     {o => 'update',
      t => 'boolean',
      h => 'if true then updates existing Similarities rather than making new',
     },
     {o => 'limit_sub',
      t => 'int',
      h => 'maximum number of subjects to enter / query'
     },
     {o => 'limit_hsp',
      t => 'int',
      h => 'maximum number of hsps to enter / subject'
     },
     {o => 'ns_mi',
      t => 'int',
      h => 'minimum number of subject filter'
     },
     {o => 'ns_ma',
      t => 'int',
      h => 'maximum number of subject filter'
     },
     {o => 'su_pv',
      t => 'float',
      h => 'summary pvalue cutoff'
     },
     {o => 'su_pi',
      t => 'float',
      h => 'summary percent identity cutoff'
     },
     {o => 'su_ln',
      t => 'int',
      h => 'summary match length cutoff'
     },
     {o => 'sp_pv',
      t => 'float',
      h => 'span pvalue cutoff'
     },
     {o => 'sp_pi',
      t => 'float',
      h => 'span percent identity cutoff'
     },
     {o => 'sp_ln',
      t => 'int',
      h => 'span match length cutoff'
     },
    ];

  $self->initialize({requiredDbVersion => {},
		     cvsRevision => '$Revision$', # cvs fills this in!
		     cvsTag => '$Name$', # cvs fills this in!
		     name => ref($self),
		     revisionNotes => 'make consistent with GUS 3.0',
		     easyCspOptions => $easycsp,
		     usage => $usage
		    });
  return $self;
}


my $ctx;
my %ignore;
my %update;			##queries with existing similarities to be updated...
my $countIgnored = 0;
my $subject_table_pk;
my $query_table_pk;
my $subject_table_id;
my $query_table_id;
my $queriesProcessed = 0;

$| = 1;

sub run {
  my $M   = shift;
  $ctx = shift;

  die "LoadBlastSimilarities: you must provide a --subject_table and --query_table\n" unless ($ctx->{cla}->{subject_table} && $ctx->{cla}->{query_table});


		
  $ctx->{'self_inv'}->setMaximumNumberOfObjects(400000);

  ##get the subject table_id
  $subject_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{cla}->{ subject_table } );
  ##and the query_table_id
  $query_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{cla}->{query_table} );
  ##get the subject_table_pk
  $subject_table_pk = $ctx->{self_inv}->getTablePKFromTableId($subject_table_id);
  ##now the query table pk..
  $query_table_pk = $ctx->{self_inv}->getTablePKFromTableId($ctx->{self_inv}->getTableIdFromTableName( $ctx->{cla}->{query_table} ));

  my $n_queries = 0;
  my $n_files   = 0;

  print $ctx->{cla}->{'commit'} ? "*** COMMIT ON ***\n" : "*** COMMIT TURNED OFF ***\n";
  print "Testing on $ctx->{cla}->{'testnumber'}\n" if $ctx->{cla}->{'testnumber'};

  # open dbi database connection
  ##note that the login and password are coming from the gus_cfg file..
  my $dbh = $ctx->{'self_inv'}->getDbHandle();

  

sub GetFileClever {
  my $F = shift;

  my $f;

  if ( $F =~ /\.gz$/ ) {
    $f = "gunzip -c $F|";
  } elsif ( $F =~ /\.Z$/ ) {
    $f = "zcat $F|";
  } elsif ( -f $F ) {
    $f = "<$F";
  } else {
    $f = GetFileClever( $F. '.gz' ) || GetFileClever( $F. '.gz' );
  }

  return $f;
}




1;

