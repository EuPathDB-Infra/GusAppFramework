package GUS::Common::Plugin::OrthologGroupsMCL;

@ISA = qw(GUS::PluginMgr::Plugin);
use strict;

use FileHandle; 

use GUS::Model::DoTS::AAOrthologExperiment;
use GUS::Model::DoTS::AAOrthologGroup;
use GUS::Model::DoTS::AASequenceSequenceGroup;
# ----------------------------------------------------------------------
# create and initalize new plugin instance.

sub new {
  my ($class) = @_;

  my $self = {};
  bless($self, $class);

  my $usage = 'Load orthologous sequence groups generated by OrthoMCL algorithm.  ("// on newline delimits submits)';

  my $easycsp =
    
     [

     { h => 'file of indexing between martrix elements and sequence identifiers',
       t => 'string',
       o => 'index',
     },
     { h => 'file of the matrix generated by OrthoMCL',
       t => 'string',
       o => 'matrix',
     },
     { h => 'description of the parameters used in OrthoMCL',
       t => 'string',
       o => 'description',
     },
     { h => 'source of the relevant sequences',
       t => 'string',
       o => 'seqsource',
     },
     

    ];

  $self->initialize({requiredDbVersion => {},
		     cvsRevision => '$Revision$', # cvs fills this in!
		     cvsTag => '$Name$', # cvs fills this in!
		     name => ref($self),
		     revisionNotes => 'make consistent with GUS 3.0',
		     easyCspOptions => $easycsp,
		     usage => $usage
		 });

  return $self;
}

# ----------------------------------------------------------------------
# plugin-global variables.


# ----------------------------------------------------------------------
# run method to do the work

sub run {
    my $self = shift;
    my $RV;

    my $fh_index = FileHandle->new('<'.$self->getCla->{'index'});
    my $fh_matrix = FileHandle->new('<'.$self->getCla->{'matrix'});
    if ($fh_index && $fh_matrix) {
	
	$self->logAlert('COMMIT', $self->getCla->{commit} ? 'ON' : 'OFF' );

	##testing exitOnFailure...
	#$self->getDb()->setExitOnSQLFailure(0);

    ############################################################
    # Put loop here...remember to undefPointerCache()!
    ############################################################

	my %id;
	while (<$fh_index>) {

	    if($_=~/^(\d+)\s+(\d+)/) {
		$id{$1}=$2;
	    }
	}
	$fh_index -> close;
#assign experiment id

	my $orthexp = GUS::Model::DoTS::AAOrthologExperiment->new();
	$orthexp->set('subclass_view','AAOrthologExperiment');
	$orthexp->set('description', $self->getCla->{'description'});
	$orthexp->set('sequence_source', $self->getCla->{'seqsource'});
	$orthexp->set('pvalue_mant',1);
	$orthexp->set('pvalue_exp', -5);
	$orthexp->set('percent_identity',0);
	$orthexp->set('percent_match',0);
	$orthexp->submit();
	my $expId = $orthexp->get('aa_seq_group_experiment_id');
	
	my $count;
	my %string;
	my $key;
	while(<$fh_matrix>) {
	    chomp;
	    next unless ($_ =~ /^[\d\s]/);
	    if($_ =~/^(\d+)\s+(.+)/) {
		$key = $1;
		$string{$key} = $2;
	    }
	    else{
		$string{$key} .= $_;
	    }
	}
	foreach my $g (keys %string) {
	    $string{$g} =~s/\$//;
	    my @mem = split(/\s+/, $string{$g});
	    my $n = scalar(@mem);
	    my $orthgrp = GUS::Model::DoTS::AAOrthologGroup -> new();
	    $orthgrp -> set('subclass_view','AAOrthologGroup');
	    $orthgrp -> set('number_of_members',$n);
	    $orthgrp -> set('aa_seq_group_experiment_id',$expId);
	    foreach my $m (@mem) {
		my $mem = GUS::Model::DoTS::AASequenceSequenceGroup -> new();
		$mem->set('aa_sequence_id', $id{$m});
		$orthgrp -> addChild($mem);
	    }
	    $orthgrp->submit(); 
	    $count++;
	    $self->getSelfInv->undefPointerCache();
	}
	$fh_matrix -> close;
	
	$RV = join(' ',
		   "processed $count ortholog groups, inserted",
		   $self->getSelfInv->getTotalInserts(),
		   'and updated',
		   $self->getSelfInv->getTotalUpdates() || 0,
		   );
    }
    
    # no file.
    else {
	$RV = join(' ',
		   'valid --index <filename> --matrix <filename> must be on the commandline',
		   $self->getCla->{filename},
		   $!);
    }
    
    $self->logAlert('RESULT', $RV);
    return $RV;
}
