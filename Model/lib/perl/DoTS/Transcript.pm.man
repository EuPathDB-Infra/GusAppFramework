
package GUS::Model::DoTS::Transcript;

# THIS CLASS HAS BEEN AUTOMATICALLY GENERATED BY THE GUS::ObjRelP::Generator 
# PACKAGE.
#
# DO NOT EDIT!!

# TO ADD FUNCTIONALITY MANUALLY, COPY THIS FILE TO Transcript.pm.man
# (or edit that file if it already exists) AND ADD THE FUNCTIONALITY THERE.
# THEN RE-GENERATE THE GUS OBJECTS.

use strict;
use GUS::Model::DoTS::Transcript_Row;



use vars qw (@ISA);
@ISA = qw (GUS::Model::DoTS::Transcript_Row);

my $debug = 0;

sub getFeatureSequence {
  my $self = shift;
  print STDERR "Transcript->getFeatureSequence\n" if $debug;
  if (!exists $self->{'sequence'}) {
    if (!$self->get('is_predicted')) {
      print STDERR "getFeatureSequence: is not predicted\n" if $debug;
      return $self->SUPER::getFeatureSequence();
    }
    my $snas = $self->getParent('DoTS::SplicedNASequence',1);
    if ($snas && $snas->get('sequence')) {
      $self->{'sequence'} = $snas->getSequence();
    } else {
      my @exons = $self->getExons();
      print STDERR "Transcript->getFeatureSequence: Have ",scalar(@exons)," exons\n" if $debug;
      foreach my $e (sort { $a->getOrderNumber() <=> $b->getOrderNumber()} @exons) {
        #		foreach my $e (sort { $a->getChild('DoTS::NALocation',1)->get('start_min') <=> $b->getChild('DoTS::NALocation',1)->get('start_min')} @exons){
        print STDERR "Getting ExonFeature sequence for exon: ".$e->getOrderNumber()." start=".$e->getChild('DoTS::NALocation',1)->get('start_min')."\n".$e->getFeatureSequence()."\n" if $debug;
        
        $self->{'sequence'} .= $e->getFeatureSequence();
      }
    }
  }
  print STDERR "getFeatureSequence: $self->{'sequence'}\n" if $debug;
  return $self->{'sequence'};
}

sub getExons {
  my $self = shift;
  my @exons;
  foreach my $r ($self->getChildren('DoTS::RNAFeatureExon',1)) {
    print STDERR "Retrieving exon: na_feature_id '".$r->getExonFeatureId()."'\n" if $debug;
    push(@exons,$r->getParent('DoTS::ExonFeature',1));
  }
  return @exons;
}

sub getFeatureLength {
  my $self = shift;
  if (!exists $self->{'featurelength'}) {
    my $length = 0;
    foreach my $e ($self->getExons()) {
      $length += $e->getFeatureLength();
    }
    $self->{'featurelength'} = $length;
  }
  return $self->{'featurelength'};
}

sub getRnaFeatExons {
  my $self = shift;
  my @exons;
  foreach my $r ($self->getChildren('DoTS::RNAFeatureExon',1)) {
    print STDERR "Retrieving exon: na_feature_id '".$r->getExonFeatureId()."'\n" if $debug;
    push(@exons,$r);
  }
  return @exons;
}


##returns the start and stop of the cds
sub getTranslationStartStop {
  my $self = shift;
  my $start;
  my $stop = 0;
  my $length = 0;
	
  foreach my $e (sort { $a->getOrderNumber() <=> $b->getOrderNumber()} $self->getRnaFeatExons()) {
    my $l = $e->getParent('DoTS::ExonFeature')->getChild('DoTS::NaLocation',1);
    $start = $length + ($l->getIsReversed() ? $l->getEndMax() - $e->getCodingStart() + 1  : $e->getCodingStart() - $l->getStartMin() + 1) if ($e->getCodingStart() ne '' && $e->getCodingStart() ne 'null' && !$start); 
    $stop = $length + ($l->getIsReversed() ? $l->getEndMax() - $e->getCodingEnd() + 1  : $e->getCodingEnd() - $l->getStartMin() + 1) if ($e->getCodingEnd() ne '' && $e->getCodingEnd() ne 'null'); 
    #$stop += $e->getCodingEnd() if defined $e->getCodingEnd();
    $length += $e->getParent('DoTS::ExonFeature', 1)->getFeatureLength();
  }
  $start = $start ? $start : 1;
  $stop = $stop ? $stop : $length;
  #$self->setTranslationStart($start);
  #$self->setTranslationStop($stop);
  return ($start,$stop);
}


1;

