##
## InsertSecondaryStructure.pm
## $Id$
##

package GUS::Supported::Plugin::InsertSecondaryStructure;
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;

use GUS::PluginMgr::Plugin;

use GUS::Model::DoTS::SecondaryStructure;
use GUS::Model::DoTS::SecondaryStructureCall;

use FileHandle;

  my $purposeBrief = "Load SAGE tag-count pairs from a file.";

  my $purpose = <<PLUGIN_PURPOSE;
This plugin loads protein secondary structure predictions,
such as those generated by PSIPRED.  Each run loads data for one protein,
creating one record in DoTS.SecondaryStructure, and one record per type of
secondary structure in DoTS.SecondaryStructureCall.  PSIPRED predicts three
types of secondary structure: coil, helix and strand ("C", "H" and "E").
PLUGIN_PURPOSE

  my $tablesAffected =
    [ ['DoTS::SecondaryStructure', 'Insert one record'],
      ['DoTS::SecondaryStructureCall', 'Insert one record per structure type'],
    ];

  my $tablesDependedOn =
    [];

  my $howToRestart = <<PLUGIN_RESTART;
This plugin has no restart facility.
PLUGIN_RESTART

  my $failureCases = <<PLUGIN_FAILURE_CASES;
PLUGIN_FAILURE_CASES

  my $notes = <<PLUGIN_NOTES;
For a protein containing n amino acids, three records
are stored in DoTS.SecondaryStructureCall, one for each type of
secondary structure.  Each string has a secondary structure 
code (C, H or E) and a string length n, in which the ith
character stores the most significant digit of the confidence
score.  In the example above, where i=1, the 1st character
of the C call is 8, the 1st character of the H call is 0,
and the 1st character of the E call is 1.

Either the directory arg must be provided OR BOTH aaSequenceId and datafile.
PLUGIN_NOTES

my $argsDeclaration =
  [

   integerArg({name           => 'aaSequenceId',
	       descr          => 'DoTS.AASequence.aa_sequence_id.  See Notes...',
	       reqd           => 0,
	       constraintFunc => undef,
	       isList         => 0, }),

   integerArg({name           => 'predAlgInvocationId',
	       descr          => '',
	       reqd           => 0,
	       constraintFunc => undef,
	       isList         => 0, }),

   stringArg({name           => 'predAlgName',
              descr          => 'The Core::Algorithm Name for the Prediction',
              reqd           => 0,
              constraintFunc => undef,
              isList         => 0, }),

   stringArg({name           => 'predAlgImpVersion',
              descr          => 'The Core::AlgorithmImplementation Version for the Prediction',
              reqd           => 0,
              constraintFunc => undef,
              isList         => 0, }),

   stringArg({name           => 'predAlgInvStart',
              descr          => 'The Core::AlgorithmInvocation StartTime for the Prediction (yyyy-mm-dd)',
              reqd           => 0,
              constraintFunc => undef,
              isList         => 0, }),

   stringArg({name           => 'predAlgInvEnd',
              descr          => 'The Core::AlgorithmInvocation EndTime for the Prediction (yyyy-mm-dd)',
              reqd           => 0,
              constraintFunc => undef,
              isList         => 0, }),
   stringArg({name           => 'predAlgInvResult',
              descr          => 'The Core::AlgorithmInvocation result for the Prediction (yyyy-mm-dd)',
              reqd           => 0,
              constraintFunc => undef,
              isList         => 0, }),
   fileArg({name           => 'datafile',
	    descr          => 'ss2 file. See Notes...',
	    reqd           => 0,
	    mustExist      => 1,
	    format         =>
'The format generated by
the PSIPRED batch.  The information stored for each amino acid, can be
seen in the following example:
  1 M C   0.827  0.008  0.142
 where:
1 is the amino-acid location
M is the single-letter amino acid code (for Methionine)
C is the highest-confidence secondary structure call
0.827 is the confidence score of a C call
0.008 is the confidence score of an H call
0.142 is the confidence score of an E call',
	    constraintFunc => undef,
	    isList         => 0, }),

   fileArg({name           => 'directory',
            descr          => 'ALL ss2 files will be loaded from this directory.  See Notes...',
	    reqd           => 0,
	    mustExist      => 1,
	    format         => 'The file names in this directory MUST be in the format sourceId.ss2',
            constraintFunc => undef,
	    isList         => 0, }),

   booleanArg({name => 'setPercentages',
	       descr => 'Calculate percent-coverage of each secondary structure call',
	       constraintFunc => undef,
	       reqd => 0,
	      }),
  ];

my $documentation = { purpose          => $purpose,
		      purposeBrief     => $purposeBrief,
		      tablesAffected   => $tablesAffected,
		      tablesDependedOn => $tablesDependedOn,
		      howToRestart     => $howToRestart,
		      failureCases     => $failureCases,
		      notes            => $notes
		    };

my $ssCount;
my $sscCount;
my $setPercentages;

sub new {
  my ($class) = @_;
  my $self    = {};
  bless($self,$class);

  $self->initialize({requiredDbVersion => 3.5,
                     cvsRevision       => '$Revision$', # cvs fills this in!
                     name              => ref($self),
                     argsDeclaration   => $argsDeclaration,
                     documentation     => $documentation
		 });

  return $self;
}

sub run {
  my ($self) = @_;
  $self->logAlgInvocationId;
  $self->logCommit;

  my $datafile = $self->getArg('datafile');
  my $aa_sequence_id = $self->getArg('aaSequenceId');
  my $pred_alg_invocation_id = $self->getArg('predAlgInvocationId');
  my $dirname = $self->getArg('directory');
  $setPercentages = $self->getArg('setPercentages');

  my $algName = $self->getArg('predAlgName');

  if($pred_alg_invocation_id && $algName) {
    $self->userError("Must provide either predAlgInvocationId or predAlgName");
  }

  $pred_alg_invocation_id = $self->getAlgInvocationId($algName) if(!$pred_alg_invocation_id);

  if($dirname && (!$aa_sequence_id && !$datafile)) {
    opendir(DIR, $dirname) || die "Cannot open directory $dirname for reading";

    while(my $fn = readdir(DIR)) {
      next if $fn =~ /^\.\.?$/;
      next if $fn !~ /\.ss2$/;

      my ($sourceId) = $fn =~ /(.+)\.ss2$/;
      my @aaSeqs = $self->sqlAsArray( Sql => "select aa_sequence_id from Dots.AASequence where source_id = '$sourceId'" );

      die "More than 1 aa_sequence_id for source_id $sourceId" if(scalar(@aaSeqs) > 1);

      if(!$aaSeqs[0]) {
        $self->log("WARNING:  No aa_sequence_id found for source_id $sourceId");
        next;
      }
      $self->_processFile("$dirname/$fn", $aaSeqs[0], $pred_alg_invocation_id);
    }
    closedir(DIR);
  }
  elsif(!$dirname && ($aa_sequence_id && $datafile)) {
    $self->_processFile($datafile, $aa_sequence_id, $pred_alg_invocation_id);
  }
  else {
    $self->userError("Must either provide a directory from which .ss2 files can be found OR a file and a corresponding aa_sequence_id");
  }
  return("Inserted $ssCount SecondaryStructures and $sscCount SecondaryStructureCounts");
}

sub _processFile {
  my ($self, $datafile, $aa_sequence_id, $pred_alg_invocation_id) = @_;

  my $fh = FileHandle->new('<'.$datafile);
  if (! $fh) {
    die ("Can't open datafile $datafile");
  }

  my ($cCalls, $hCalls, $eCalls,
      $cConf, $hConf, $eConf,
      $cCount, $hCount, $eCount, $aaCount);

  while (<$fh>) {
    chomp;

    next if(!$_);
    next if(/^#/);

    $aaCount++;

    $cConf = substr($_, 13, 5);
    $hConf = substr($_, 20, 5);
    $eConf = substr($_, 27, 5);

    $cCalls .= substr($cConf, 0, 1);
    $hCalls .= substr($hConf, 0, 1);
    $eCalls .= substr($eConf, 0, 1);

    if ($cConf > $hConf && $cConf > $eConf) {
       $cCount++;
     } elsif ($hConf > $eConf) {
       $hCount++;
     } else {
       $eCount++;
     }
  }

  $fh->close();

  $self->logVerbose("C calls: $cCalls");
  $self->logVerbose("H calls: $hCalls");
  $self->logVerbose("E calls: $eCalls");

  my $secondaryStructure = GUS::Model::DoTS::SecondaryStructure->new({
      aa_sequence_id => $aa_sequence_id,
      pred_alg_invocation_id => $pred_alg_invocation_id,
  });

  my $cPct = $cCount * 100 / $aaCount;
  my $hPct = $hCount * 100 / $aaCount;
  my $ePct = $eCount * 100 / $aaCount;

  makeSecondaryStructureCall($secondaryStructure, 'C', $cCalls, $cPct);
  makeSecondaryStructureCall($secondaryStructure, 'H', $hCalls, $hPct);
  makeSecondaryStructureCall($secondaryStructure, 'E', $eCalls, $ePct);

  $secondaryStructure->submit();
  $ssCount++;

  $self->undefPointerCache();
}


sub makeSecondaryStructureCall {

  my ($secondaryStructure, $structureType, $calls, $pct) = @_;

  my $call = GUS::Model::DoTS::SecondaryStructureCall->new({
      structure_type => $structureType,
  });

  $call->setParent($secondaryStructure);
  $call->setCallConfidence($calls);

  if ($setPercentages) {
    $call->setPercentage($pct);
  }

  $sscCount++;
}

sub getAlgInvocationId {
  my ($self, $algName) = @_;

  if(!$algName) {
    $self->userError("Must provied either a predAlgInvocationId or predAlgName");
  }

  my $algImpVersion = $self->getArg('predAlgImpVersion');
  my $algInvStart = $self->getArg('predAlgInvStart');
  my $algInvEnd = $self->getArg('predAlgInvEnd');
  my $algInvResult = $self->getArg('predAlgInvResult');

  my $sql = "select algorithm_invocation_id 
             from Core.ALGORITHM a, Core.ALGORITHMIMPLEMENTATION imp, Core.ALGORITHMINVOCATION inv
             where a.algorithm_id = imp.algorithm_id 
              and imp.algorithm_implementation_id = inv.algorithm_implementation_id
              and a.name = '$algName'
              and imp.version = '$algImpVersion'
              and inv.start_time = to_date('$algInvStart', 'yyyy-mm-dd')";

$sql .= " and inv.end_time = to_date('$algInvEnd', 'yyyy-mm-dd')" if ($algInvEnd);
$sql .= " and inv.result = '$algInvResult'" if ($algInvResult);

  my @algInvIds = $self->sqlAsArray(Sql => $sql);

  if(scalar(@algInvIds) > 1) {
    $self->userError("Many AlgorithmInvocation rows Found with start=$algInvStart, version=$algImpVersion, and name=$algName"); 
  }
  if(!$algInvIds[0]) {
    $self->userError("No AlgorithmInvocation row Found with start=$algInvStart, version=$algImpVersion, and name=$algName"); 
  }
  return($algInvIds[0]);
}

sub undoTables {
  my ($self) = @_;

  return ('DoTS.SecondaryStructure',
	  'DoTS.SecondaryStructureCall',
	 );
}


1;
