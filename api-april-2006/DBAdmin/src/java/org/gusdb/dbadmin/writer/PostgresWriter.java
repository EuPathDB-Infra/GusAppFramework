/*
 *  Created on Oct 28, 2004
 *  $Id$
 */
package org.gusdb.dbadmin.writer;

import java.io.IOException;
import java.util.ArrayList;

import org.gusdb.dbadmin.model.Column;
import org.gusdb.dbadmin.model.Database;
import org.gusdb.dbadmin.model.DatabaseObject;
import org.gusdb.dbadmin.model.GusSchema;
import org.gusdb.dbadmin.model.GusTable;
import org.gusdb.dbadmin.model.GusView;
import org.gusdb.dbadmin.model.VersionView;
import org.gusdb.dbadmin.model.Schema;
import org.gusdb.dbadmin.model.Sequence;
import org.gusdb.dbadmin.model.View;
import org.gusdb.dbadmin.util.ColumnPair;

/**
 * Writes a given database's DDL for the PostgreSQL RDBMS.
 * 
 * @version $Revision$ $Date$
 * @author msaffitz
 */
public class PostgresWriter extends RelationalDatabaseWriter {

    /**
     * Writes the given database to the internal OutputStreamWriter.
     * 
     * <p>
     * Schemata are written first, then tables, primary keys, views,  view
     * rules, indexes, foreign key constraints, and sequences.
     * </p>
     * 
     * <p>
     * The entire process is wrapped in a transaction, so it's all or nothing.
     * </p>
     * 
     * @param db               Database to be written
     * @exception IOException
     * @see org.gusdb.dbadmin.writer.SchemaWriter#writeDatabase(java.io.OutputStreamWriter,
     *      org.gusdb.dbadmin.model.Database)
     */
    protected void writeDatabase( Database db ) throws IOException {
        log.debug( "Writing database" );
        oStream.write( "-- Automatically generated by GusDBA.\n" );
        oStream.write( "-- GUS DDL for PostgreSQL.\n" );

        if ( db.getName( ) != null ) {
            oStream.write( "-- Generated for " + db.getName( ) + "\n" );
        }

        oStream.write( "\n\n" );
        oStream.write( "BEGIN;\n\n" );
        oStream.write( "-- Schemata\n\n" );

        for ( Schema schema : db.getAllSchemas( ) ) {
            oStream.write( "CREATE SCHEMA " + schema.getName( ) + ";\n" );
        }

        oStream.flush( );
        oStream.write( "\n-- Tables, Views, Indexes, and Primary Key Constraints\n\n" );

        for ( Schema schema : db.getAllSchemas( ) ) {
            writeTables( schema );
            writeViews( schema );
        }

        oStream.flush( );
        oStream.write( "\n-- Foreign Key Constraints\n\n" );

        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( GusTable table : schema.getTables( ) ) {
                writeFKConstraints( table );
                writeUQConstraints( table );
                oStream.write( "\n" );
            }
        }

        oStream.flush( );
        oStream.write( "\n-- Sequences\n\n" );

        for ( GusSchema schema : db.getGusSchemas( ) ) {
            for ( GusTable table : schema.getTables( ) ) {
                writeSequence( table.getSequence( ) );
                oStream.write( "\n" );
            }
        }

        oStream.write( "\n\nCOMMIT;\n\n" );
        oStream.write( "--EOF\n" );
        written = new ArrayList<DatabaseObject>( );
    }

    /**
     * Uses the superclass's writeView method, and then writes the appropriate
     * rules for the given view
     * 
     * @param view             The View to be written
     * @throws IOException
     */
    protected void writeView( View view ) throws IOException {
        if ( written.contains( view ) ) {
            return;
        }
        super.writeView( view );
        if ( view instanceof GusView ) {
            writeViewRules( (GusView) view );
        }else if ( view instanceof VersionView ) {
            writeVersionViewRules( (VersionView) view );
        }
    }

    /**
     * Since PostgreSQL doesn't support updatable views, this is a hack that
     * uses rules to mimick the updatable view functionality.
     * 
     * 
     * @param view DOCUMENT ME!
     * @throws IOException DOCUMENT ME!
     */
    private void writeViewRules( GusView view ) throws IOException {
        oStream.write( "CREATE RULE " + view.getName( ) + "_" + random.nextInt( 100000 ) + " AS ON INSERT TO "
                + view.getSchema( ).getName( ) + "." + view.getName( ) + " DO INSTEAD INSERT INTO  "
                + view.getTable( ).getSchema( ).getName( ) + "." + view.getTable( ).getName( ) + " ( " );

        boolean first = true;
        for ( ColumnPair columnPair : view.getColumns() ) {
            if ( !first ) {
                oStream.write( ", " );
            }
            oStream.write( columnPair.getTableName( ) );
            first = false;
        }

        oStream.write( " ) VALUES ( " );

        first = true;
        for ( ColumnPair columnPair : view.getColumns() ) {
            if ( !first ) {
                oStream.write( ", " );
            }
            oStream.write( "new." + columnPair.getViewName( ) );
            first = false;
        }

        oStream.write( " );\n\n" );

        oStream.write( "CREATE RULE " + view.getName( ) + "_" + random.nextInt( 100000 ) + " AS ON UPDATE TO "
                + view.getSchema( ).getName( ) + "." + view.getName( ) + " DO INSTEAD UPDATE "
                + view.getTable( ).getSchema( ).getName( ) + "." + view.getTable( ).getName( ) + " SET " );

        first = true;
        for ( ColumnPair columnPair : view.getColumns() ) {
            if ( !first ) {
                oStream.write( ", " );
            }
            oStream.write( columnPair.getTableName( ) + " = new." + columnPair.getViewName( ) );
            first = false;
        }

        oStream.write( " WHERE " + view.getTable( ).getPrimaryKeyName( ) + " = old."
                + view.getTable( ).getPrimaryKeyName( ) + ";\n\n" );

        oStream.write( "CREATE RULE " + view.getName( ) + "_" + random.nextInt( 100000 ) + " AS ON DELETE TO "
                + view.getSchema( ).getName( ) + "." + view.getName( ) + " DO INSTEAD DELETE FROM "
                + view.getTable( ).getSchema( ).getName( ) + "." + view.getTable( ).getName( ) + " WHERE "
                + view.getTable( ).getPrimaryKeyName( ) + " = old." + view.getTable( ).getPrimaryKeyName( ) + ";\n\n" );
        oStream.flush( );
    }

    protected void writeSequence( Sequence sequence ) throws IOException {
        oStream.write( "CREATE SEQUENCE " + sequence.getTable( ).getSchema( ).getName( ) + "." );
        oStream.write( sequence.getName( ) + " START " + sequence.getStart( ) + ";\n" );
        oStream.flush( );
    }


    /**
     * Since PostgreSQL doesn't support updatable views, this is a hack that
     * uses rules to mimick the updatable view functionality.
     * 
     * Version views are now not updatable since they 
     * don't have a PK, so we limit rules to insertion
     * 
     * @param view DOCUMENT ME!
     * @throws IOException DOCUMENT ME!
     */
    private void writeVersionViewRules( VersionView view ) throws IOException {
        oStream.write( "CREATE RULE " + view.getName( ) + "_" + random.nextInt( 100000 ) + " AS ON INSERT TO "
                + view.getSchema( ).getName( ) + "." + view.getName( ) + " DO INSTEAD INSERT INTO  "
                + view.getTable( ).getSchema( ).getName( ) + "." + view.getTable( ).getName( ) + " ( " );

        boolean first = true;
        for ( ColumnPair columnPair : view.getColumns() ) {
            if ( !first ) {
                oStream.write( ", " );
            }
            oStream.write( columnPair.getTableName( ) );
            first = false;
        }

        oStream.write( " ) VALUES ( " );

        first = true;
        for ( ColumnPair columnPair : view.getColumns() ) {
            if ( !first ) {
                oStream.write( ", " );
            }
            oStream.write( "new." + columnPair.getViewName( ) );
            first = false;
        }

        oStream.write( " );\n\n" );

    }

    /**
     * DOCUMENT ME!
     * 
     * @param type DOCUMENT ME!
     * @return DOCUMENT ME!
     * @throws RuntimeException DOCUMENT ME!
     */
    protected String getType( Column.ColumnType type ) {

        if ( type == Column.ColumnType.DATE ) {
            return "TIMESTAMP";
        }
        else if ( type == Column.ColumnType.STRING ) {
            return "VARCHAR";
        }
        else if ( type == Column.ColumnType.CLOB ) {
            return "TEXT";
        }
        else if ( type == Column.ColumnType.BLOB ) {
            return "BYTEA";
        }
        else if ( type == Column.ColumnType.CHARACTER ) {
            return "CHAR";
        }
        else if ( type == Column.ColumnType.FLOAT ) {
            return "FLOAT";
        }
        else if ( type == Column.ColumnType.NUMBER ) {
            return "NUMERIC";
        }

        log.error( "Unable to get postgres type: " + type.toString( ) );
        throw new RuntimeException( "Unable to get postgres type: " + type.toString( ) );
    }
}
