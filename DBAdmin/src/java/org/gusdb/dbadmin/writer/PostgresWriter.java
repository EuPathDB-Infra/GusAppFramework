/*
 *  Created on Oct 28, 2004
 *  $Id$
 */
package org.gusdb.dbadmin.writer;

import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;

import org.gusdb.dbadmin.model.ColumnType;
import org.gusdb.dbadmin.model.Database;
import org.gusdb.dbadmin.model.GusSchema;
import org.gusdb.dbadmin.model.GusTable;
import org.gusdb.dbadmin.model.Schema;
import org.gusdb.dbadmin.model.Sequence;
import org.gusdb.dbadmin.model.View;
import org.gusdb.dbadmin.util.ColumnPair;


/**
 * Writes a given database's DDL for the PostgreSQL RDBMS.
 * 
 * @version $Revision$ $Date$
 * @author msaffitz
 */
public class PostgresWriter
    extends RelationalDatabaseWriter {

    /**
     * Writes the given database to the internal OutputStreamWriter.
     * 
     * <p>
     * Schemata are written first, then tables, primary keys, views,  view
     * rules, indexes, foreign key constraints, and sequences.
     * </p>
     * 
     * <p>
     * The entire process is wrapped in a transaction, so it's all or nothing.
     * </p>
     * 
     * @param db               Database to be written
     * @exception IOException
     * @see org.gusdb.dbadmin.writer.SchemaWriter#writeDatabase(java.io.OutputStreamWriter,
     *      org.gusdb.dbadmin.model.Database)
     */
    protected void writeDatabase(Database db)
                          throws IOException {
        log.debug("Writing database");
        oStream.write("-- Automatically generated by GusDBA.\n");
        oStream.write("-- GUS DDL for PostgreSQL.\n");

        if (db.getName() != null) {
            oStream.write("-- Generated for " + db.getName() + "\n");
        }

        oStream.write("\n\n");
        oStream.write("BEGIN;\n\n");
        oStream.write("-- Schemata\n\n");

        for (Iterator i = db.getSchemas().iterator(); i.hasNext();) {
            oStream.write(
                    "CREATE SCHEMA " + ((Schema)i.next()).getName() + ";\n");
        }

        oStream.flush();
        oStream.write(
                "\n-- Tables, Views, Indexes, and Primary Key Constraints\n\n");

        for (Iterator i = db.getSchemas().iterator(); i.hasNext();) {

            Schema schema = (Schema)i.next();
            writeTables(schema);
            writeViews(schema);
        }

        oStream.flush();
        oStream.write("\n-- Foreign Key Constraints\n\n");

        for (Iterator i = db.getSchemas().iterator(); i.hasNext();) {

            Schema schema = (Schema)i.next();

            if (schema.getClass() == GusSchema.class) {

                for (Iterator j = schema.getTables().iterator(); j.hasNext();) {
					GusTable table = (GusTable) j.next();
                    writeFKConstraints(table);
					writeUQConstraints(table);
                    oStream.write("\n");
                }
            }
        }

        oStream.flush();
        oStream.write("\n-- Sequences\n\n");

        for (Iterator i = db.getSchemas().iterator(); i.hasNext();) {

            Schema schema = (Schema)i.next();

            if (schema.getClass() == GusSchema.class) {

                for (Iterator j = schema.getTables().iterator(); j.hasNext();) {

                    GusTable table = (GusTable)j.next();
                    writeSequence(table.getSequence());
                    oStream.write("\n");
                }
            }
        }

        oStream.write("\n\nCOMMIT;\n\n");
        oStream.write("--EOF\n");
        written = new HashSet();
    }

    /**
     * Uses the superclass's writeView method, and then writes the appropriate
     * rules for the given view
     * 
     * @param view             The View to be written
     * @throws IOException
     */
    protected void writeView(View view)
                      throws IOException {
        super.writeView(view);
        writeViewRules(view);
    }

    /**
     * Since PostgreSQL doesn't support updatable views, this is a hack that
     * uses rules to mimick the updatable view functionality.
     * 
     * @param view DOCUMENT ME!
     * @throws IOException DOCUMENT ME!
     */
    private void writeViewRules(View view)
                         throws IOException {
        oStream.write(
                "CREATE RULE " + view.getName() + "_" + 
                random.nextInt(100000) + " AS ON INSERT TO " + 
                view.getSchema().getName() + "." + view.getName() + 
                " DO INSTEAD INSERT INTO  " + 
                view.getTable().getSchema().getName() + "." + 
                view.getTable().getName() + " ( ");

        boolean first = true;

        for (Iterator i = view.getColumns().iterator(); i.hasNext();) {

            if (!first) {
                oStream.write(", ");
            }

            oStream.write(((ColumnPair)i.next()).getTableName());
            first = false;
        }

        oStream.write(" ) VALUES ( ");
        first = true;

        for (Iterator i = view.getColumns().iterator(); i.hasNext();) {

            if (!first) {
                oStream.write(", ");
            }

            oStream.write("new." + ((ColumnPair)i.next()).getViewName());
            first = false;
        }

        oStream.write(" );\n\n");
        oStream.write(
                "CREATE RULE " + view.getName() + "_" + 
                random.nextInt(100000) + " AS ON UPDATE TO " + 
                view.getSchema().getName() + "." + view.getName() + 
                " DO INSTEAD UPDATE " + 
                view.getTable().getSchema().getName() + "." + 
                view.getTable().getName() + " SET ");

		first = true;
        for (Iterator i = view.getColumns().iterator(); i.hasNext();) {

            if (!first) {
                oStream.write(", ");
            }

            ColumnPair columnPair = (ColumnPair)i.next();
            oStream.write(
                    columnPair.getTableName() + " = new." + 
                    columnPair.getViewName());
            first = false;
        }

        oStream.write(
                " WHERE " + view.getTable().getPrimaryKeyName() + " = old." + 
                view.getTable().getPrimaryKeyName() + ";\n\n");
        oStream.write(
                "CREATE RULE " + view.getName() + "_" + 
                random.nextInt(100000) + " AS ON DELETE TO " + 
                view.getSchema().getName() + "." + view.getName() + 
                " DO INSTEAD DELETE FROM " + 
                view.getTable().getSchema().getName() + "." + 
                view.getTable().getName() + " WHERE " + 
                view.getTable().getPrimaryKeyName() + " = old." + 
                view.getTable().getPrimaryKeyName() + ";\n\n");
        oStream.flush();
    }

	protected void writeSequence( Sequence sequence ) throws IOException {
		oStream.write( "CREATE SEQUENCE " +
						sequence.getTable().getSchema().getName() + "." );
		oStream.write( sequence.getName() + " START " +
						sequence.getStart() + ";\n" );
		oStream.flush();
	}
	
    /**
     * DOCUMENT ME!
     * 
     * @param type DOCUMENT ME!
     * @return DOCUMENT ME!
     * @throws RuntimeException DOCUMENT ME!
     */
    protected String getType(ColumnType type) {

        if (type == ColumnType.DATE) {
            return "TIMESTAMP";
        } else if (type == ColumnType.STRING) {
            return "VARCHAR";
        } else if (type == ColumnType.CLOB) {
            return "TEXT";
        } else if (type == ColumnType.CHARACTER) {
            return "CHAR";
        } else if (type == ColumnType.FLOAT) {
            return "FLOAT";
        } else if (type == ColumnType.NUMBER) {
            return "NUMERIC";
        }

        log.error("Unable to get postgres type: " + type.toString());
        throw new RuntimeException("Unable to get postgres type: " + 
                                   type.toString());
    }
}
