package org.gusdb.model.DoTS;

import java.sql.*;

import org.biojava.bio.*;
import org.biojava.bio.seq.*;
import org.biojava.bio.seq.io.*;
import org.biojava.bio.symbol.*;

import java.util.*;

import java.math.*;

import java.util.Date;
import org.gusdb.objrelj.*;

/**
 * NASequence.java.man
 *
 * Wrapper class that contains methods specific for manipulating
 * DNA and protein sequences.
 *
 * @author Dave Barkan
 * @version $Revision$ $Date$ $Author$
 */
public class NASequence extends NASequence_Row {
    
    /**
     * Start coordinate of the cached sequence region.
     */
    protected Long startSequence = null;

    /**
     * End coordinate of the cached sequence region.
     */
    protected Long endSequence = null;

    // Constructor
    public NASequence () {}
    
    public void setBounds(Long start, Long end){
	startSequence = start;
	endSequence = end;
    }

    // JC: Temporarily commented out
    /*
    public void getSubSequence(RemoteGUSServer gi, String session, String pswd){
	Long pk = getNaSequenceId();
	SymbolList subSeq = null;

	try {
	    subSeq = gi.retrieveSubSequence(session,  startSequence, endSequence, pk);
	    setInitial("sequence", subSeq);

	}
	catch (Exception e){
	    System.out.println(e.getMessage());
	    e.printStackTrace();
	}
    }
    */

    public Long getStart(){
	return startSequence;
    }

    public Long getEnd(){
	return endSequence;
    }

    public void setCache (Clob sequence){

	//for now get whole string from clob and put into symbol list
	//later will want to get it one section at a time so the whole string isn't 
	//loaded into memory--problem is it's a bit difficult to add a symbol-list to 
	//the end of another without creating a new symbol-list (which will eventually
	//allocate as much memory as loading the whole string).
	
	//also will eventually implement PackedSymbolList
	try {
	    
	    //throw exception if start or end is null

	    FiniteAlphabet dnaAlphabet = DNATools.getDNA();
	    long start = startSequence.longValue();
	    int len = (int)(endSequence.longValue() - start + 1);
	       
	    String dnaStr = sequence.getSubString(start, len);
	    SymbolList dna =  DNATools.createDNA(dnaStr);
	 
	    SymbolTokenization dnaToke = dnaAlphabet.getTokenization("token");
	 
	    String seqString2 = dnaToke.tokenizeSymbolList(dna);
	    System.out.println ("sequence for this assembly: " + seqString2);
	 
	    // When I update this note that the length of the sequence may be too large for that int
	    setInitial("sequence", dna);
	}
	catch (Exception e){
	    System.out.println(e.getMessage());
	    e.printStackTrace();
	}
    } 

} // NASequence
