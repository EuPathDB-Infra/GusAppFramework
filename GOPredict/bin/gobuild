#!@perl@

use strict;

use lib "$ENV{GUS_HOME}/lib/perl";
use GUS::Pipeline::Manager;
use GUS::Pipeline::MakeTaskDirs;
use CBIL::Util::PropertySet;
use File::Basename;

use FileHandle;

$| = 1;
umask 002;



###########################  Properties  ##################################


my $propertiesFile = $ARGV[0];

&usage unless -e $propertiesFile;

# [name, default (or null if reqd), comment]
my @properties = 
(
 # global pipeline information
 ["stopBefore",   "none",  "the step to stop before.  uses the signal name"],
 ["goBuildDir",         "",  "local GO Predict update dir"],
 ["externalDbDir", "", "directory for downloaded data from external databases"],
 ["goPredictRelease",          "",  "eg 5 or 6"],
 ["globalExcludeIea", "", "whether to not consider TREMBL IEA sequences at all when going through the rule creation process (yes or no)"],
 ["buildDate" ,   "031401", "approximate start date of build"],
 ["taxonId" ,   "", "taxonId for the species we are applying rules to (hum is 8, mouse is 14)"],
 ["speciesNickname",              "",  "eg mus, hum"],

 #names of latest releases of different organism sequences
 ["currentWorm", "", "name of latest wormpep release"],
 ["currentFly", "", "name of latest fly release"],
 ["currentYeast", "", "name of latest yeast release"],
 ["currentTair", "", "name of latest Arabidopsis release"],
 ["currentSwissprot", "", "name of latest Swissprot release"],
 ["currentTrembl", "", "name of latest Trembl release"],
 ["currentTremblSubset", "", "output file in which to write subset of trembl sequences that have annotated GO Terms"], 
 ["currentMgi", "", "name of latest mapping file between mgi and swissprot"],

 #names of go association files to organism sequences
 ["flyAssocFile", "", "name of file with go associations to fly sequences"],
 ["wormAssocFile", "", "name of file with go associations to worm sequences"],
 ["yeastAssocFile", "", "name of file with go associations to yeast sequences"],
 ["mgiAssocFile", "", "name of file with go associations to mgi sequences"],
 ["tairAssocFile", "", "name of file with go associations to tair sequences"],
 ["sptrAssocFile", "", "name of file with go associations to sptr sequences"],

 #directories within the overall third party data directory to store retrieved data
 ["tairDirectory", "", "name of directory in which to store arabidopsis sequences"], 
 ["yeastDirectory", "", "name of directory in which to store yeast sequences"],
 ["swissprotDirectory", "", "name of directory in which to store swissprot sequences"], 
 ["tremblDirectory", "", "name of directory in which to store trembl sequences"],
 ["flyDirectory", "", "name of directory in which to store fly sequences"],
 ["wormDirectory", "", "name of directory in which to store worm sequences"],
 ["mgiDirectory", "", "name of directory in which to store mgi-swissprot mapping file"],
 ["goDirectory", "", "name of directory in which to store GO Term files"],
 ["assocDirectory", "", "name of directory in which to store GO Association files"],
  
 #doIt properties
 
 ["extractOrgProteinSeqs", "", "yes or no"],
 ["blastSeqs", "", "yes or no"],
 ["downloadGOTerms", "", "yes or no"],
 ["downloadGOAssoc", "", "yes or no"],
 ["downloadWorm", "", "yes or no"],
 ["downloadFly", "", "yes or no"],
 ["downloadArabidopsis", "", "yes or no"],
 ["downloadSwissprot", "", "yes or no"],
 ["downloadTREMBL", "", "yes or no"],
 ["downloadYeast", "", "yes or no"],
 ["downloadMGIInfo", "", "yes or no"],
 ["insertWorm", "", "yes or no"],
 ["insertFly", "", "yes or no"],
 ["insertArabidopsis", "", "yes or no"],
 ["insertSwissprot", "", "yes or no"],
 ["insertTREMBL", "", "yes or no"],
 ["insertYeast", "", "yes or no"],
 ["insertGOTerms", "", "yes or no"],
 ["insertFlyGoAssoc", "", "yes or no"],
 ["insertYeastGoAssoc", "", "yes or no"],
 ["insertWormGoAssoc", "", "yes or no"],
 ["insertArabidopsisGoAssoc", "", "yes or no"],
 ["insertSpTrGoAssoc", "", "yes or no"],
 ["insertMgiGoAssoc", "", "yes or no"],
 ["generateAAFilterFiles", "", "yes or no"],


 #external database ids
 ["go_function_db", "", "database id for GO Function branch"],
 ["go_process_db", "", "database id for GO Process branch"],
 ["go_component_db", "", "database id for GO Component branch"],

 #external database release ids
 ["fly_db_rls_id", "", "database release id for fly"],
 ["worm_db_rls_id", "", "database release id for worm"],
 ["tair_db_rls_id", "", "database release id for arabidopsis"],
 ["yeast_db_rls_id", "", "database relaease id for yeast"],
 ["sp_db_rls_id", "", "database release id for swissprot"],
 ["tr_db_rls_id", "", "database release id for trembl"],
 ["go_function_db_rel", "", "database release id for GO Function branch (set after loading GO Terms)"],
 ["go_process_db_rel", "", "database release id for GO Process branch (set after loading GO Terms)"],
 ["go_component_db_rel", "", "database release id for GO Component branch (set after loading GO Terms)"],
 ["smart_db_rls_id", "", "database release id for Smart CDD Domains"],
 ["pfam_db_rls_id", "", "database release id for Pfam CDD Domains"],
 ["load_db_rls_id", "", "database release id for Load CDD Domains"],
 ["cog_db_rls_id", "", "database release id for Cog CDD Domains"],
 ["cd_db_rls_id", "", "database release id for cd CDD Domains"],
 ["prodom_db_rls_id", "", "database release id for Prodom Domains"],
 ["kog_db_rls_id", "", "database release id for Cog CDD Domains"],

 #Blast
 #global blast param files
 ["blastsimilarity.taskSize", "",  "number of seqs to process per blastsimilarity subtask"],
 ["liniacServer",         "",  "full name of liniac server"],
 ["dotsSeqDir",         "",  "where to find prodom.fsa file in dots build directory"],
 ["serverPath",           "",  "full path of dots update dir on liniac server"],
 ["nodePath",             "",  "full path of scratch dir on liniac node"],

 #prodom blast param files
 ["blastsimilarity.Bparam", "", "paramter B for blastsimilarity"], 
 ["blastsimilarity.Vparam", "", "paramter V for blastsimilarity"],
 ["blastsimilarity.prodomEparam", "", "paramter E for prodom blastsimilarity"],
 ["blastsimilarity.Tparam", "", "paramter T for blastsimilarity"],
 ["blastsimilarity.Wparam", "", "paramter W for blastsimilarity"],
 ["prodomBlastType", "", "blast type to blast external sequences agains prodom domains"],
 ["wuBlastBinPathLiniac",         "",  "path of wu blast bin dir on Liniac"],

 #cdd blast param files
 ["ncbiBlastBinPathLiniac",         "",  "path of ncbi blast bin dir on Liniac"],  
 ["blastsimilarity.Pparam", "", "paramter P for blastsimilarity"], 
 ["blastsimilarity.Aparam", "", "paramter A for blastsimilarity"],
 ["blastsimilarity.cddEparam", "", "paramter E for cdd blastsimilarity"],
 ["cddBlastType", "", "blast type to blast external sequences agains cdd domains"],

 #other
 ["gusConfigFile", "", "user's GUS configuration file for making database connections"],
 ["ext_seq_table_id", "", "Table Id for DoTS.ExternalAASequence"], 
 ["iPSRestart", "", "no idea yet"],
 ["aa_filter_directory", "", "directory to put AA Filter File to make GO Rules"],
 ["iea_id", "", "id in gus of IEA GO evidence code"],
 ["learn_rules_restart_id", "", "algorithm invocation id of MakeGoPredictionRules if restart"],
 ["function_root_go_id", "", "ID (in GO:XXXXXXX format)  of the root of the molecular function branch of the Gene Ontology."],
 ["protein_table_id", "", "Core.TableInfo table ID of the DoTS.Protein Table"],
 ["old_go_function_db_rel", "", "database release ID for GO Terms for existing associations (before this build)"],
 ); 


###########################  Initialization  ##################################


my $propertySet  = CBIL::Util::PropertySet->new($propertiesFile, \@properties);

my $goBuildDir = $propertySet->getProp('goBuildDir');  #goBuildDir: /files/cbil/data/cbil/GOPredict

my $buildName = &makeBuildName($propertySet->getProp('speciesNickname'));  # releaseNUMBER 

my $pipelineDir = "$goBuildDir/$buildName"; #/files/cbil/data/cbil/ptolemy/cbil/data/cbil/GOPredict/release#



###################  The Pipeline  ##########################

#initialize

my $mgr = GUS::Pipeline::Manager->new($pipelineDir, $propertySet, $propertiesFile);

&createGoPredictPipelineDir();

#download external data

&downloadFly();

&downloadWorm();

&downloadYeast();

&downloadArabidopsis();

&downloadSwissprot();

&downloadTREMBL();

&downloadMGIInfo();

&downloadGOAssoc();

&downloadGOTerms();

#insert external data

&insertFly();

&findTREMBLSubset();

&insertTREMBLSubset();

&insertWorm();

&insertYeast(); 

&insertArabidopsis();

&insertSwissprot();

&insertGOTerms();

&insertFlyGoAssoc();

&insertWormGoAssoc();

&insertYeastGoAssoc();

&insertArabidopsisGoAssoc();

&insertSpTrGoAssoc();

&insertMgiGoAssoc();

#extract sequences

&extractFlyWithAssociations();

&extractYeastWithAssociations();

&extractArabidopsisWithAssociations();

&extractWormWithAssociations();

&extractSwissprotWithAssociations();

&extractTremblWithAssociations();

#blast sequences against motifs

&copyPipelineDirToLiniac();

&blastGOSeqsAgainstMotifs();

&copySimsFromLiniac();

&substituteCDDPKs();

&insertAllExternalProteinSimilarities();

#make and apply rules

&generateAAFilterFiles();

&learnGORules();

&evolveGoHierarchy();

#dtb--before i do this, take out go_term_id restriction from getGusAssocIdResultSet!
&deprecateUnevolvedAssociations(); #dtb--do I need to do this for apply to work?  Make sure only deprecate human!


#&applyGORules();   

$mgr->goodbye("Pipeline complete!\n");

#########################   Pipeline Subroutines   ########################


sub createGoPredictPipelineDir {
        
    if (-e "$pipelineDir/seqfiles"){

	print "$pipelineDir already exists\n";
	return;
    }
    
    #paths on liniac server
    my $serverPath = $propertySet->getProp('serverPath');
    my $nodePath = $propertySet->getProp('nodePath');

    #parameters that will go into blast files
    my $bsTaskSize = $propertySet->getProp('blastsimilarity.taskSize');
    my $dotsSeqDir = $propertySet->getProp('dotsSeqDir');
   
    #prodom blast params
    my $wuBlastBinPathLiniac = $propertySet->getProp('wuBlastBinPathLiniac');
    my $bsBparam = $propertySet->getProp('blastsimilarity.Bparam');
    my $bsVparam = $propertySet->getProp('blastsimilarity.Vparam');
    my $bsWparam = $propertySet->getProp('blastsimilarity.Wparam');
    my $bsTparam = $propertySet->getProp('blastsimilarity.Tparam');
    my $bsProdomEparam = $propertySet->getProp('blastsimilarity.prodomEparam');
    my $prodomBlastType = $propertySet->getProp('prodomBlastType'); #blastp

    #cdd blast params
    my $ncbiBlastBinPathLiniac = $propertySet->getProp('ncbiBlastBinPathLiniac');
    my $bsPparam = $propertySet->getProp('blastsimilarity.Pparam');
    my $bsAparam = $propertySet->getProp('blastsimilarity.Aparam');
    my $bsCddEParam = $propertySet->getProp('blastsimilarity.cddEparam');
    my $cddBlastType = $propertySet->getProp('cddBlastType'); #rps blast

    $mgr->runCmd("mkdir -p $pipelineDir/seqfiles");
 
    #dtb:  make these into params?
    my @subjectNames = ("fly", "worm", "yeast", "arabidopsis", "swissprot", "trembl"); 
    
    my $cddBlastParamsString;
    my $prodomBlastParamsString;
    
    $prodomBlastParamsString = "-wordmask=seg+xnu\nW=$bsWparam\nT=$bsTparam\nB=$bsBparam\nV=$bsVparam\nE=$bsProdomEparam";
    $cddBlastParamsString = "-a $bsAparam\n-e $bsCddEParam\n-p $bsPparam";

    foreach my $subjectName (@subjectNames){
	#make "prodom" and "cdd" into parameters?
	&makeSimilarityDir($subjectName, "prodom", $buildName, $goBuildDir, 
			   $serverPath, $nodePath, $bsTaskSize, 
			   $wuBlastBinPathLiniac,
			   "prodom.fsa", $dotsSeqDir, "$subjectName.fsa",  '(\S+)', $prodomBlastType, 
			   $prodomBlastParamsString);


	&makeSimilarityDir($subjectName, "cdd", $buildName, $goBuildDir, 
			   $serverPath, $nodePath, $bsTaskSize, 
			   $ncbiBlastBinPathLiniac,
 			   "cdd/All", $dotsSeqDir, "$subjectName.fsa", '\w+\|\w+\|\d+\s+(\w+)', $cddBlastType, 
			   $cddBlastParamsString);
	 
    }

    $mgr->runCmd("chmod -R g+w $goBuildDir/$buildName");
}


sub downloadGOAssoc{
      
    my $signal = "downloadGOAssoc";
    return if $mgr->startStep("Downloading GO Associations", $signal, 'downloadGOAssoc');
    
 #   $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadGoAssoc.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');
    my $assocDir = $propertySet->getProp('assocDirectory');
    my $downloadSubDir = "$externalDbDir/$assocDir/$date";
  
    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $ftpsite = "ftp://ftp.geneontology.org/pub/go/gene-associations/";
    my $flyFile = $propertySet->getProp('flyAssocFile');
    my $wormFile = $propertySet->getProp('wormAssocFile');
    my $yeastFile = $propertySet->getProp('yeastAssocFile');
    my $mgiFile = $propertySet->getProp('mgiAssocFile');
    my $tairFile = $propertySet->getProp('tairAssocFile');
    my $sptrFile = $propertySet->getProp('sptrAssocFile');


    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=3 -A \"$flyFile, $wormFile, $yeastFile, $mgiFile, $tairFile, $sptrFile\" -P $downloadSubDir $ftpsite";

    $mgr->runCmd($cmd);
    
    $mgr->endStep($signal);

}

sub downloadMGIInfo {

    my $signal = "downloadMGIInfo";

    return if $mgr->startStep("Downloading MGI Info", $signal,'downloadMGIInfo');

    #$ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadMGIInfo.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $mgiDir = $propertySet->getProp('mgiDirectory');
    my $date = $propertySet->getProp('buildDate');

    my $downloadSubDir = "$externalDbDir/$mgiDir/$date";
    
    my $currentMgi = $propertySet->getProp('currentMgi');

    $mgr->runCmd("mkdir -p $downloadSubDir");

    my $ftpsite = "ftp://ftp.informatics.jax.org/pub/reports/$currentMgi";
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=2 -P $downloadSubDir $ftpsite";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
} 

sub downloadArabidopsis {
    my $signal = "downloadArabidopsis";
    
    return if $mgr->startStep("Downloading Arabidopsis", $signal, 'downloadArabidopsis');
    
    #$ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadArabidopsis.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $tairDir = $propertySet->getProp('tairDirectory');
    my $date = $propertySet->getProp('buildDate');
    my $downloadSubDir = "$externalDbDir/arabidopsis/$date";

    my $currentTair = $propertySet->getProp('currentTair');
    
    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $ftpsite = "ftp://ftp.tigr.org/pub/data/a_thaliana/ath1/SEQUENCES/$currentTair";
    
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=5 -P $downloadSubDir  $ftpsite";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub insertArabidopsis {

    my $date = $propertySet->getProp('buildDate');

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $tairDir = $propertySet->getProp('tairDirectory');
    my $currentTair = $propertySet->getProp('currentTair');
    
    my $tairSeqFile = "$externalDbDir/$tairDir/$date/$currentTair";

    my $logFile = "$pipelineDir/logs/insertArabidopsis.log";

    my $tairDB = $propertySet->getProp('tair_db_rls_id');
    
    my $regex_src_id = "^\\>(\\S+)\\s";  
    my $regex_name = "^\\>\\S+\\s(\\S*)\\s";
    my $regex_desc = "^\\>\\S+\\s(.*)";

   my $args = "--table_name DoTS::ExternalAASequence --sequencefile $tairSeqFile --external_database_release_id $tairDB --regex_source_id \"$regex_src_id\"  --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\" --writeFile tairSeqsFile  --log_frequency 500 --no_check";
    
    $mgr->runPlugin("insertArabidopsis", 
	 	    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Arabidopsis", 'insertArabidopsis');

}

sub downloadFly{
    
    my $signal = "downloadFly";
    
    return if $mgr->startStep("Downloading Fly", $signal, 'downloadFly');
    
#   $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadFly.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $flyDir = $propertySet->getProp('flyDirectory');
    my $date = $propertySet->getProp('buildDate');
    my $downloadSubDir = "$externalDbDir/$flyDir/$date";

    my $currentFlyFile = $propertySet->getProp('currentFly'); 
    
    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $ftpsite = "ftp://ftp.fruitfly.org/pub/download/dmel_RELEASE3-1/FASTA/$currentFlyFile";
    
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --proxy=on --cut-dirs=4 -P $downloadSubDir $ftpsite";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub insertFly {

    #note: don't need to call startStep in insert methods as runPlugin does that
    #for you

    my $date = $propertySet->getProp('buildDate');

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $flyDir = $propertySet->getProp('flyDirectory');
    my $currentFly = $propertySet->getProp('currentFly');

    my $flySeqFile = "$externalDbDir/$flyDir/$date/$currentFly";

    my $logFile = "$pipelineDir/logs/insertFly.log";

    my $flyDB = $propertySet->getProp('fly_db_rls_id');

    my $regex_src_id = "^\\>(\\S+)\\s";
    my $regex_secondary_id = "^\\>.*from_gene\\[\\S+\\s\\S+\\s(FBgn\\S+)\\]";
    my $regex_name = "^\\>.*from_gene\\[\\S+\\s(\\S+)\\sFBgn\\S+\\]";
    my $regex_desc = "^\\>.*from_gene\\[\\S+\\s\\S+\\sFBgn\\S+\\](.*)";

    my $args = "--verbose --table_name \"DoTS::ExternalAASequence\" --sequencefile \"$flySeqFile\" --external_database_release_id $flyDB --regex_source_id \"$regex_src_id\"  --regex_name \"$regex_name\"  --regex_secondary_id \"$regex_secondary_id\" --regex_desc \"$regex_desc\" --sequenceFile $flySeqFile  --log_frequency 500 --no_check ";
    
    $mgr->runPlugin("insertFly", 
	 	    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Fly", 'insertFly');
    
    
}

sub downloadSwissprot {
    
    my $signal = "downloadSwissprot";
    
    return if $mgr->startStep("Downloading Swissprot", $signal, 'downloadSwissprot');
    
#    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadSwissprot.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $date = $propertySet->getProp('buildDate');
    my $spDir = $propertySet->getProp('swissprotDirectory');
    my $downloadSubDir = "$externalDbDir/$spDir/$date";
    
    my $currentSwissprot = $propertySet->getProp('currentSwissprot');

    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $ftpsite = "ftp://ftp.ebi.ac.uk/pub/databases/uniprot/knowledgebase/$currentSwissprot";
    
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=4 -P $downloadSubDir $ftpsite";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub insertSwissprot {

    my $date = $propertySet->getProp('buildDate');

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $swissprotDir = $propertySet->getProp('swissprotDirectory');

    my $currentSwissprot = $propertySet->getProp('currentSwissprot');

    my $spSeqFile = "$externalDbDir/$swissprotDir/$date/$currentSwissprot";

    my $logFile = "$pipelineDir/logs/insertSwissprot.log";

    my $spDB = $propertySet->getProp('sp_db_rls_id');

    my $regex_name = "^\\>(\\S+)\\s";
    my $regex_src_id = "^\\>\\S+\\s\\((\\w+)\\)\\s";  
    my $regex_desc = "^\\>\\S+\\s\\(\\w+\\)\\s(.*)";
    
    my $args = "--table_name DoTS::ExternalAASequence --sequencefile $spSeqFile --external_database_release_id $spDB --regex_source_id \"$regex_src_id\"  --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\" --writeFile spSeqsFile  --log_frequency 500 --no_check";
    
    $mgr->runPlugin("insertSwissprot", 
	 	    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Swissprot", 'insertSwissprot');

}

sub downloadTREMBL {

    my $signal = "downloadTREMBL";
    
    return if $mgr->startStep("Downloading TREMBL", $signal, 'downloadTREMBL');
    
    #$ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';
    
    my $logfile = "$pipelineDir/logs/downloadTREMBL.log";
    
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $tremblDir = $propertySet->getProp('tremblDirectory');
    my $date = $propertySet->getProp('buildDate');
    my $downloadSubDir = "$externalDbDir/$tremblDir/$date";
    
    my $currentTrembl = $propertySet->getProp('currentTrembl');

    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $ftpsite = "ftp://ftp.ebi.ac.uk/pub/databases/uniprot/knowledgebase/$currentTrembl";
    
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=4 -P $downloadSubDir $ftpsite";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);

}

sub findTREMBLSubset {

    my $signal = "findTREMBLSubset";
    
    return if $mgr->startStep("findTREMBLSubset", $signal, 'insertTREMBL');

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    
    my $date = $propertySet->getProp('buildDate');

    my $tremblDir = $propertySet->getProp('tremblDirectory');
    my $assocDir = $propertySet->getProp('assocDirectory');

    my $downloadTremblSubDir = "$externalDbDir/$tremblDir/$date";
    my $downloadAssocSubDir = "$externalDbDir/$assocDir/$date";
    
    my $assocData = &createTREMBLAssocHash($downloadAssocSubDir);
    &writeTREMBLSubset($downloadTremblSubDir, $assocData);
    
    $mgr->endStep($signal);


}

sub createTREMBLAssocHash{
#change to data directory
    my ($downloadSubDir) = @_;
    my $assocData;

    my $sptrAssocFile = $propertySet->getProp("sptrAssocFile");
    
    if ($sptrAssocFile =~ /(.*)\.gz$/){
	$sptrAssocFile = $1;
	$mgr->runCmd("gunzip $downloadSubDir/$sptrAssocFile");
    }

    my $fh = FileHandle->new("<$downloadSubDir/$sptrAssocFile");

    if (!($fh)){
	die "Cannot find $sptrAssocFile for swissprot/trembl!";
    }
    my $excludeIea = $propertySet->getProp('globalExcludeIea');
    my $counter = 0;
    my $inCounter = 0;
    while (<$fh>){
	chomp;
	$counter++;
	my @columns = split(/\t/, $_);
	my $tremblId = $columns[1];
	my $evdCode = $columns[6];
	unless ($excludeIea eq "yes" && $evdCode eq "IEA"){
	    $inCounter ++;
	    print STDERR "added $tremblId to hash\n" if ($inCounter % 100 == 0);
	    $assocData -> {$tremblId} = 1;
	}
	if ($counter % 100000 == 0){ print STDERR "processed current entry $tremblId with code $evdCode\n";}
    }
    return $assocData;
}

sub writeTREMBLSubset{
    my ($downloadSubDir, $assocData) = @_;

    my $currentTremblIn = $propertySet->getProp('currentTrembl');
    
    if ($currentTremblIn =~ /(\S+).gz/){
      $mgr->runCmd("gunzip $downloadSubDir/$currentTremblIn");
      $currentTremblIn = $1;
    }
    
    my $currentTremblOut = $propertySet->getProp('currentTremblSubset');

    open (OUTPUT, ">>$downloadSubDir/$currentTremblOut");
   
    my $fh = FileHandle->new("<$downloadSubDir/$currentTremblIn");
    my $subsetSeq = 0;
    my $counter = 0;
    while (<$fh>){
	$counter++;
	#chomp;
	if (/^\>/) {  #defline
	    my $line = $_;
	    my ($idOne) = $line =~ /(\w+)\s/;
	    if ($assocData->{$idOne}){
		print OUTPUT "$line";
		$subsetSeq = 1;
	    }
	    else {
		$subsetSeq = 0;
	    }
	}
	else { #sequence
	    my $line = $_;
	    if ($subsetSeq == 1){
		print OUTPUT $line;
	    }
	}
    }
}

sub insertTREMBLSubset {
 
    my $date = $propertySet->getProp('buildDate');
       
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $tremblDir = $propertySet->getProp('tremblDirectory');
    my $tremblSubset = $propertySet->getProp('currentTremblSubset');
 
    my $trSeqFile = "$externalDbDir/$tremblDir/$date/$tremblSubset";
    
    my $logFile = "$pipelineDir/logs/insertTrembl.log";
    
    my $trDB = $propertySet->getProp('tr_db_rls_id');
    
    #fasta convention: name (source_id) description    
    
    my $regex_name = "^\\>(\\S+)\\s";
    my $regex_src_id = "^\\>\\S+\\s\\((\\w+)\\)\\s";  
    my $regex_desc = "^\\>\\w+\\s\\(\\w+\\)\\s(.*)";
    
    my $args = "--table_name DoTS::ExternalAASequence --sequencefile $trSeqFile --external_database_release_id $trDB --regex_source_id \"$regex_src_id\"  --regex_name \"$regex_name\"  --regex_desc \"$regex_desc\" --writeFile trSeqsFile  --log_frequency 1000 --no_check ";
    
    $mgr->runPlugin("insertTrembl", 
		    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Trembl", 'insertTREMBL');
    
    
}

 sub downloadWorm {
    
    my $signal = "downloadWorm";
    
    return if $mgr->startStep("Downloading Worm", $signal, 'downloadWorm');
    
#    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadWorm.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $wormDir = $propertySet->getProp('wormDirectory'); 
    my $date = $propertySet->getProp('buildDate');
    my $downloadSubDir = "$externalDbDir/$wormDir/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");
 
    my $currentWormRealFile = $propertySet->getProp('currentWorm');
   
    my $ftpsite = "ftp://ftp.sanger.ac.uk/pub/databases/wormpep/$currentWormRealFile/$currentWormRealFile";

    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=4 -P $downloadSubDir  $ftpsite";
    
    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub insertWorm {
    my $date = $propertySet->getProp('buildDate');
    

    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $wormDir = $propertySet->getProp('wormDirectory');
    my $wormSeqFile = $propertySet->getProp('currentWorm');
    my $fullWormSeqFile = "$externalDbDir/$wormDir/$date/$wormSeqFile";
 
    my $logFile = "$pipelineDir/logs/insertWorm.log";

    my $wormDB = $propertySet->getProp('worm_db_rls_id');
 
    my $regex_src_id = "^\\>\\S+\\s(\\S+)\\s";
    my $regex_secondary_id = "^\\>.*\\sprotein_id:(\\S+)";
    my $regex_desc = "^\\>\\S+\\s\\S+\\s(.*)\\sprotein";
    
    my $args = "--table_name DoTS::ExternalAASequence --sequencefile $fullWormSeqFile --external_database_release_id $wormDB --regex_source_id \"$regex_src_id\"  --regex_secondary_id \"$regex_secondary_id\" --regex_desc \"$regex_desc\" --writeFile wormSeqsFile  --no_check --log_frequency 500 ";
    
    $mgr->runPlugin("insertWorm", 
	 	    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Worm", 'insertWorm');

}

sub downloadYeast {
    my $signal = "downloadYeast";
    
    return if $mgr->startStep("Downloading Yeast", $signal, 'downloadYeast');
    
   # $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadYeast.log";
    
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $yeastDir = $propertySet->getProp('yeastDirectory');
    my $date = $propertySet->getProp('buildDate');
    my $downloadSubDir = "$externalDbDir/$yeastDir/$date";
    
    $mgr->runCmd("mkdir -p $downloadSubDir");
    
    my $currentYeast = $propertySet->getProp('currentYeast');

    my $ftpsite = "ftp://genome-ftp.stanford.edu/pub/yeast/data_download/sequence/genomic_sequence/orf_protein/";
     
    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH -A \"$currentYeast\" --cut-dirs=6 -P $downloadSubDir  $ftpsite";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}

sub insertYeast {
    
    my $date = $propertySet->getProp('buildDate');
    
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $yeastDir = $propertySet->getProp('yeastDirectory');
    my $currentYeast = $propertySet->getProp('currentYeast');

    my $yeastSeqFile = "$externalDbDir/$yeastDir/$date/$currentYeast";
    
    my $logFile = "$pipelineDir/logs/insertYeast.log";
    
    my $yeastDB = $propertySet->getProp('yeast_db_rls_id');
    
    my $regex_src_id = "^\\>(\\S+)\\s";  
    my $regex_name = "^\\>\\S+\\s+(\\S+)\\s";
    my $regex_secondary_id = "^\\>.*\\sSGDID:(\\S+)\\,\\s";
    my $regex_desc = "^\\>.*\\sSGDID\\:\\S+\\,\\s(.+)";

    my $args = "--table_name DoTS::ExternalAASequence --sequencefile $yeastSeqFile --external_database_release_id $yeastDB --regex_source_id \"$regex_src_id\" --regex_name \"$regex_name\"  --regex_secondary_id \"$regex_secondary_id\" --regex_desc \"$regex_desc\" --writeFile yeastSeqsFile  --log_frequency 500 --no_check";
    
    $mgr->runPlugin("insertYeast", 
	 	    "GUS::Common::Plugin::InsertNewExternalSequences", $args,
		    "Inserting Yeast", 'insertYeast');

}

sub downloadGOTerms {

    my $signal = "downloadGOTerms";
    
    return if $mgr->startStep("Downloading GO Terms", $signal, 'downloadGOTerms');

#    $ENV{ftp_proxy} = 'http://proxy.pcbi.upenn.edu:3128/';

    my $logfile = "$pipelineDir/logs/downloadGOTerms.log";

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');
    my $goDir = $propertySet->getProp('goDirectory');

    my $downloadSubDir = "$externalDbDir/$goDir/$date";

    $mgr->runCmd("mkdir -p $downloadSubDir");
 
    my $ftpsite = "ftp://ftp.geneontology.org/pub/go/ontology/";

    my $cmd = "wget -t5 -o $logfile -m -np -nd -nH --cut-dirs=3 -A \"function.ontology, component.ontology, process.ontology\" -P $downloadSubDir $ftpsite";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
    
}

sub insertGOTerms{

    my $externalDbDir = $propertySet->getProp('externalDbDir');

    my $date = $propertySet->getProp('buildDate');
    my $goDir = $propertySet->getProp('goDirectory');

    my $processDbId = $propertySet->getProp('go_process_db');
    my $componentDbId = $propertySet->getProp('go_component_db');
    my $functionDbId = $propertySet->getProp('go_function_db');

    my $downloadSubDir = "$externalDbDir/$goDir/$date";
    
    my $args = "--file_path $downloadSubDir --create_release --function_db_id $functionDbId --process_db_id $processDbId --component_db_id $componentDbId";
    $mgr->runPlugin("insertGOTerms", "GUS::GOPredict::Plugin::LoadGoOntology",
			    $args, "Loading GO Ontology", 'insertGOTerms');

    # LoadGoOntology.pm
}

sub insertFlyGoAssoc{
    
    my $flyDb = $propertySet->getProp('fly_db_rls_id');
    
    my $flatFile = $propertySet->getProp("flyAssocFile");
    my $orgArgs = "--org_external_db_release_list $flyDb";
    my $doIt = "insertFlyGoAssoc";

    &_insertGoAssoc($flatFile, $orgArgs, $doIt);
}   

sub insertWormGoAssoc{
    
    my $wormDb = $propertySet->getProp('worm_db_rls_id');
    my $flatFile = $propertySet->getProp("wormAssocFile");
    my $orgArgs = "--org_external_db_release_list $wormDb";
    my $doIt = "insertWormGoAssoc";

    &_insertGoAssoc($flatFile, $orgArgs, $doIt);

}   

sub insertYeastGoAssoc{
    
    my $yeastDb = $propertySet->getProp('yeast_db_rls_id');
    my $flatFile = $propertySet->getProp("yeastAssocFile");
    my $orgArgs = "--org_external_db_release_list $yeastDb";
    my $doIt = "insertYeastGoAssoc";

    &_insertGoAssoc($flatFile, $orgArgs, $doIt);

}   

sub insertArabidopsisGoAssoc{
    
    my $tairDb = $propertySet->getProp('tair_db_rls_id');
    my $flatFile = $propertySet->getProp("tairAssocFile");
    my $orgArgs = "--org_external_db_release_list $tairDb";
    my $doIt = "insertArabidopsisGoAssoc";
    
    &_insertGoAssoc($flatFile, $orgArgs, $doIt);

}   

sub insertMgiGoAssoc{
    
    my $spDb = $propertySet->getProp('sp_db_rls_id');
    my $trDb = $propertySet->getProp('tr_db_rls_id');
    my $flatFile = $propertySet->getProp("mgiAssocFile");
    
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $date = $propertySet->getProp('buildDate');
    my $mgiDir = $propertySet->getProp('mgiDirectory');
    my $mgiFile = $propertySet->getProp('currentMgi');
    
    my $mgiFilePath =  "$externalDbDir/$mgiDir/$date/$mgiFile";

    my $orgArgs = "--org_external_db_release_list $spDb,$trDb --mgi_file $mgiFilePath";
    my $doIt = "insertMgiGoAssoc";
    
    &_insertGoAssoc($flatFile, $orgArgs, $doIt);
    
}   

sub insertSpTrGoAssoc{
    my $spDb = $propertySet->getProp('sp_db_rls_id');
    my $trDb = $propertySet->getProp('tr_db_rls_id');

    my $excludeIea = "";
    my $excludeIeaProp = $propertySet->getProp('globalExcludeIea');
    if ($excludeIeaProp eq 'yes'){
	$excludeIea .= "--exclude_iea";
    }
    
    my $flatFile = $propertySet->getProp("sptrAssocFile");
    my $orgArgs = "--org_external_db_release_list $spDb,$trDb $excludeIea";
    my $doIt = "insertSpTrGoAssoc";

    &_insertGoAssoc($flatFile, $orgArgs, $doIt);
    
}   

sub _insertGoAssoc{

    my ($flatFile, $args, $doIt) = @_;

    my $signal = $doIt;

    my $goDB =  $propertySet->getProp('go_function_db_rel');
    my $functionGoId = $propertySet->getProp('function_root_go_id');
  
    my $externalDbDir = $propertySet->getProp('externalDbDir');
    my $date = $propertySet->getProp('buildDate');
    my $assocDir = $propertySet->getProp('assocDirectory');
    my $filePath = "$externalDbDir/$assocDir/$date/$flatFile";
  
    my $date = $propertySet->getProp('buildDate');

    my $goAssocFileDir = "$externalDbDir/goassoc/$date";

    my $args = "$args --flat_file $filePath --go_ext_db_rel_id $goDB --log_frequency 1000 --function_root_go_id $functionGoId";

    $mgr->runPlugin($signal, "GUS::GOPredict::Plugin::LoadGoAssoc",
		    $args, "Loading GO Associations", $doIt);
}


sub extractArabidopsisWithAssociations {
    my $dbId = $propertySet->getProp('tair_db_rls_id');
   
    &_extractOrgProteinSeqs ("arabidopsis", $dbId);

}

sub extractFlyWithAssociations{

    my $dbId = $propertySet->getProp('fly_db_rls_id');
   
    &_extractOrgProteinSeqs ("fly", $dbId);

}

sub extractYeastWithAssociations{
    my $dbId = $propertySet->getProp('yeast_db_rls_id');
   
    &_extractOrgProteinSeqs ("yeast", $dbId);

}

sub extractWormWithAssociations{
    my $dbId = $propertySet->getProp('worm_db_rls_id');
   
    &_extractOrgProteinSeqs ("worm", $dbId);

}

sub extractSwissprotWithAssociations{
    my $dbId = $propertySet->getProp('sp_db_rls_id');
   
    &_extractOrgProteinSeqs ("swissprot", $dbId);

}

sub extractTremblWithAssociations{
    my $dbId = $propertySet->getProp('tr_db_rls_id');
   
    &_extractOrgProteinSeqs ("trembl", $dbId);
}


#for now the same as extractProteinSeqs in dots build
sub _extractOrgProteinSeqs {
    my ($name, $orgDbId) = @_;

    my $signal = "${name}Extract";

    return if $mgr->startStep("Extracting $name external protein sequences from GUS", $signal, 'extractOrgProteinSeqs');
    my $goDb = $propertySet->getProp('go_function_db_rel');
    my $extSeqTableId =  $propertySet->getProp('ext_seq_table_id');

    my $sql = "select eas.aa_sequence_id, eas.name, eas.source_id, eas.secondary_identifier, eas.description, eas.sequence from DoTS.ExternalAASequence eas, DoTS.GOAssociation ga, SRes.GOTerm gt where ga.table_id = $extSeqTableId and ga.row_id = eas.aa_sequence_id and eas.external_database_release_id = $orgDbId and ga.go_term_id = gt.go_term_id and gt.external_database_release_id = $goDb";

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my $seqFile = "$pipelineDir/seqfiles/$name.fsa";
    my $logFile = "$pipelineDir/logs/${name}Extract.log";

    #outputFile: fasta file, created here

    my $cmd = "dumpDistinctSequencesFromTable.pl --gusConfigFile $gusConfigFile  --outputFile $seqFile --idSQL \"$sql\"  2>> $logFile";

    $mgr->runCmd($cmd);

    $mgr->endStep($signal);
}


#DTB 2/11/04:  Going to start dealing with actual <sequence>.fsa files soon.  If these keep getting
#hardcoded put them into properties file.  Then go above with all extract methods and replace
#the hardcoded organism name with what we got from properties file.




#copy directory $buildName to liniac server directory 
#/genomics/binf/scratch/goPredicts/

#make sure these directories are correct!

#DTB: Make sure nodepath is correct, which is /scratch/user/dbarkan -- make
#sure my permissions are ok
sub copyPipelineDirToLiniac {


    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');
    my $fromDir = $goBuildDir;
    my $fromFile = $buildName;
    
    my $signal = "dir2liniac";
    return if $mgr->startStep("Copying $goBuildDir/$buildName to $serverPath on $liniacServer", $signal, 'blastSeqs');

    $mgr->copyToLiniac($fromDir, $fromFile, $liniacServer, $serverPath);

    $mgr->endStep($signal);

}

sub blastGOSeqsAgainstMotifs{
    my ($name) = @_;
    
    my $serverPath = $propertySet->getProp('serverPath');
    
    my $signal = "findGoSimilarities";
    return if $mgr->startStep("Starting similarities between domains and external sequences on liniac", $signal, 'blastSeqs');
    
    $mgr->endStep($signal);

    my $liniacCmdMsg = "submitPipelineJob runGoSimilarities $serverPath/$buildName NUMBER_OF_NODES";
    my $liniacLogMsg = "monitor $serverPath/$buildName/logs/*.log and xxxxx.xxxx.stdout";

    $mgr->exitToLiniac($liniacCmdMsg, $liniacLogMsg, 1);
}

sub copySimsFromLiniac{

    my $serverPath = $propertySet->getProp('serverPath');
    my $liniacServer = $propertySet->getProp('liniacServer');

    my $signal = "copySimsFromLiniac";
    return if $mgr->startStep("Copying external protein similarities from $liniacServer", 
			 $signal, 'blastSeqs');

    my @domainNames = ("prodom", "cdd");
    
    my @subjectNames = ("fly", "worm", "yeast", "arabidopsis", "swissprot", "trembl"); 

    foreach my $domain (@domainNames){
	foreach my $subjectName (@subjectNames) {
	    my $fullName = "$subjectName-$domain";
	    
	    $mgr->copyFromLiniac($liniacServer, 
				 "$serverPath/$buildName/similarity/$fullName/master/mainresult", 
				 "blastSimilarity.out.gz", 
				 "$pipelineDir/similarity/$fullName");
	}
    }
    $mgr->endStep($signal);
}



sub substituteCDDPKs {
    
    my $signal = "substituteCDDPKs";

    return if $mgr->startStep("Substitituting primary keys into CDD similarities file",	 $signal);

    my $smartDB = $propertySet->getProp('smart_db_rls_id');

    my $pfamDB = $propertySet->getProp('pfam_db_rls_id');

    my $loadDB = $propertySet->getProp('load_db_rls_id');

    my $cogDB = $propertySet->getProp('cog_db_rls_id');

    my $cdDB = $propertySet->getProp('cd_db_rls_id');

    my $kogDB = $propertySet->getProp('kog_db_rls_id');

    my $gusConfigFile = $propertySet->getProp('gusConfigFile');

    my @cddFiles = ("fly-cdd", "worm-cdd", "yeast-cdd", "arabidopsis-cdd", "swissprot-cdd", "trembl-cdd");
    foreach my $cddFile (@cddFiles){
      my $file = "$mgr->{pipelineDir}/similarity/$cddFile/blastSimilarity.out.gz";
      $mgr->runCmd("gunzip $file");
      my $infile = "$pipelineDir/similarity/$cddFile/blastSimilarity.out";
      my $outfile = "$pipelineDir/similarity/$cddFile/blastSimilarity.out.correctPK";
      my $logfile = "$pipelineDir/logs/$signal.log";

      my $sql = "select source_id,aa_sequence_id from dots.motifaasequence where external_database_release_id in ($smartDB,$pfamDB,$loadDB,$cogDB,$cdDB,$kogDB)";

	$mgr->runCmd("cat $infile | substitutePrimKeysInSimilarity --subjectSQL \"$sql\" --verbose --gusConfigFile $gusConfigFile > $outfile 2>> $logfile");
    }
    $mgr->endStep($signal);
}

sub insertAllExternalProteinSimilarities {

    my @domainNames = ("prodom", "cdd");
    my @subjectNames = ("fly", "worm", "yeast", "arabidopsis", "swissprot", "trembl"); 


    foreach my $domain (@domainNames){
	foreach my $subjectName (@subjectNames) {
	    my $fullName = "$subjectName-$domain";
	    &insertExternalProteinSimilarities ($fullName, "DoTS.ExternalAASequence");
	    #dtb: check if need owner in parameter
	}
    }
}

sub insertExternalProteinSimilarities {
    my ($name, $subjectTable) = @_;
    if ($name =~ /prodom/) {
      my $prodomFile = "$pipelineDir/similarity/$name/blastSimilarity.out.gz";
      $mgr->runCmd("gunzip $prodomFile");
    }
    my $file = "$pipelineDir/similarity/$name/blastSimilarity.out";
    $file .= ".correctPK" if ($name eq "cdd");

    my $restart = $propertySet->getProp('iPSRestart');

    my $args = "--file $file --verbose --restartAlgInvs $restart --queryTable ExternalAASequence --subjectTable $subjectTable --subjectsLimit 50 --hspsLimit 10";

    $mgr->runPlugin("loadSims_$name", 
		    "GUS::Common::Plugin::LoadBlastSimFast", $args,
		    "Loading $name similarities");
}



sub generateAAFilterFiles{

    my $signal = "generateAAFilterFiles";
    return if $mgr->startStep("Generating AA Filter Files", $signal, 'generateAAFilterFiles');
    my $ieaParams = "";

    #when making iea and non iea rules, want to change this to be a different param, not globalExcludeIea
    #also will be making more than one aa filter file

    my $excludeIea = $propertySet->getProp('globalExcludeIea');
    if ($excludeIea eq "yes"){
	my $ieaId = $propertySet->getProp('iea_id');
	$ieaParams .= "--exclude_iea 1 --iea_id $ieaId";
    }
    my $queryTableId = $propertySet->getProp('ext_seq_table_id');
    my $goDb = $propertySet->getProp('go_function_db_rel');
    my $aaFilterDirectory = $propertySet->getProp('aa_filter_directory');
    
    $mgr->runCmd("generateAAFilterFile --table_id $queryTableId --go_ext_db_rel_id $goDb --directory $aaFilterDirectory $ieaParams");

    $mgr->endStep($signal);

}

#only no IEA so far
sub learnGORules{

    my $goDb = $propertySet->getProp('go_function_db_rel');
    my $aaFilterDirectory = $propertySet->getProp('aa_filter_directory');
    my $restartArgs;
    my $signal = "learnGORules";
    my $restart = 0;
#    my $restart = $propertySet->getProp('learn_rules_restart_id');
    if ($restart){
	$restartArgs = "--restart --previous_invocation_ids $restart";
    }

    my $smartDB = $propertySet->getProp('smart_db_rls_id');
    my $pfamDB = $propertySet->getProp('pfam_db_rls_id');
    my $loadDB = $propertySet->getProp('load_db_rls_id');
    my $cogDB = $propertySet->getProp('cog_db_rls_id');
    my $cdDB = $propertySet->getProp('cd_db_rls_id');
    my $prodomDB = $propertySet->getProp('prodom_db_rls_id');
    my $kogDB = $propertySet->getProp('kog_db_rls_id');

    my $args = "--aa_filter_file $aaFilterDirectory/aaFilterFileNoIea $restartArgs --cf_hnp 10 --cf_hps 0.98 --cf_hpv 1e-60 --cf_mnp 5 --cf_mps 0.9 --cf_mpv 1e-40 --er_n 5 --er_ncf 0.8 --er_use 0 --go_ext_db_rel_id $goDb --id_db $kogDB,$smartDB,$pfamDB,$loadDB,$cogDB,$cdDB,$prodomDB  --pa_ml 99 --pa_sl 2 --pd_n 2 --sliding most-generous --sm_len 3 --sm_n 1 --sm_nom 5 --sm_ps 10 --sl_gr sing,leaf,ncle,npar,onep --sm_pv 1e-50 --gus_nobj 500000";

    $mgr->runPlugin($signal, "GUS::GOPredict::Plugin::MakeGoPredictionRules",  $args, 
			    "Learning GO Rules");
    

}

sub evolveGoHierarchy{

    my $signal = "evolveGoHierarchy";

    my $taxonId = $propertySet->getProp('taxonId');

    my $oldGoVersion =  $propertySet->getProp('old_go_function_db_rel');
    my $newGoVersion = $propertySet->getProp('go_function_db_rel');
    my $functionRootGoId =  $propertySet->getProp('function_root_go_id');
    my $proteinTableId = $propertySet->getProp('protein_table_id');
    
    my $args = "--verbose --evolve_go_hierarchy --query_taxon_id $taxonId --old_go_release_id $oldGoVersion --new_go_release_id $newGoVersion --function_root_go_id \"$functionRootGoId\" --protein_table_id $proteinTableId";

    $mgr->runPlugin($signal, "GUS::GOPredict::Plugin::GoPlugin", $args, "Evolving GO Hierarchy");
}


sub applyGORules{
    my $makeNewGORules = $propertySet->getProp('makeNewGORules');
    my $GOversion = $propertySet->getProp('GOversion');
    my $species = $propertySet->getProp('speciesNickname');
    my $prodom_db_id = $propertySet->getProp('prodom_db_id');
    my $load_db_id = $propertySet->getProp('load_db_id');
    my $pfam_db_id = $propertySet->getProp('pfam_db_id');
    my $smart_db_id = $propertySet->getProp('smart_db_id');
    
    my $sql = " rs.row_alg_invocation_id >= 111286 and ( rs.confidence in ('high','medium') OR (rs.confidence = 'low' AND rs.reviewer_id is NULL))";

    my $xdb = "$prodom_db_id,$load_db_id,$pfam_db_id,$smart_db_id";
    my $likeGOVer = "\%$GOversion\%";
    my $sqlFilter = "sim.pvalue_exp <= -5";
    my $ignore_existing = $makeNewGORules eq 'yes'? 0 : 1; 

    my $args = " --verbose --mode add  --rule-sql-filter \"$sql\" --guide ${species}dots --qs-type na --go-ver \"$likeGOVer\" --pv-ratio .80 --pv-threshold 1e-30 --ss-xdb $xdb --ignore-expred $ignore_existing  --sql-filter \"$sqlFilter\"";

    $mgr->runPlugin("applyGORules", "GUS::GOPredict::Plugin::MakeGoPredictions", $args, 
		    "Applying GO Rules"); 

}

sub deleteProteinGOPredictions {

    my $makeNewGORules = $propertySet->getProp('makeNewGORules');

    return if $makeNewGORules eq "yes";  # hack for now 

    my $GOversion = $propertySet->getProp('GOversion');
    my $taxonId = $propertySet->getProp('taxonId');
    
    my $sql = "SELECT pgf.protein_go_function_id FROM RNA r, Protein p, ProteinGoFunction pgf, GOFunction gf,  Assembly ass, RNASequence rs, NAFeature naf  WHERE ass.taxon_id = $taxonId and ass.na_sequence_id = naf.na_sequence_id and naf.na_feature_id = rs.na_feature_id and r.rna_id = rs.rna_id and p.rna_id = r.rna_id and  pgf.protein_id = p.protein_id and pgf.manually_reviewed = 0 and pgf.go_function_id = gf.go_function_id and gf.go_cvs_version  = '$GOversion'";

    my $args = "--idSQL \"$sql\" --table_name 'ProteinGOFunction' --primary_key 'protein_go_function_id'";

    $mgr->runPlugin("deleteProteinGOPredictions", "GUS::GOPredict::Plugin::DeleteGoPredictions", 
	
	    $args, "Deleting Protein GO predictions"); 

}

sub copyGOPredictions {

    my $GOversion = $propertySet->getProp('GOversion');
    my $taxonId = $propertySet->getProp('taxonId');
    my $GOrootId = $propertySet->getProp('GOrootId');

    my $alg_inv_id = 125852;  # must be obtained for current run of MakeGoPredictions - see applyGORules sub

    # HACK: must hard code the alg_inv_id (this sub is going away next build)

    # remove the following line when you have set $alg_inv_id for hum
    #$mgr->error("MUST SET alg_inv_id in copyGOPredictions()") if ($taxonId != 14);
    
    my $idSQL = "select aa_sequence_go_function_id from aasequencegofunction where row_alg_invocation_id = $alg_inv_id and go_function_id != $GOrootId";

    my $idExclSQL = "select distinct pgf.protein_id from RNA r, Protein p, ProteinGoFunction pgf, GOFunction gf, Assembly ass, RNASequence rs, NAFeature naf where ass.taxon_id = $taxonId and ass.na_sequence_id = naf.na_sequence_id and naf.na_feature_id = rs .na_feature_id and r.rna_id = rs.rna_id and p.rna_id = r.rna_id and pgf.protein_id = p.protein_id and pgf.manually_reviewed = 1 and pgf.go_function_id = gf.go_function_id and gf.go_cvs_version  = '$GOversion'";

    my $args = "--idSQL \"$idSQL\" --idExclSQL \"$idExclSQL\" --verbose";

    $mgr->runPlugin("copyGOPredictions", "GUS::GOPredict::Plugin::CopyAASeqGoFuncToProtGoFunc", $args, 
		    "Copying GO predictions from AA to Protein"); 
}


sub cleanGORules{
    my $taxonId = $propertySet->getProp('taxonId');
}




sub makeBuildName {
    my ($nickName) = @_;
    return "release" . $propertySet->getProp('goPredictRelease') . "/" . $nickName;

}

sub usage {
    print STDERR "usage:  gobuild propertiesfile\n";
    exit 1;
}







