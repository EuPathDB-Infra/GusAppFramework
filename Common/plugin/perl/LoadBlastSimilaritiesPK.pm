############################################################
## Change Package name....
############################################################
package LoadBlastSimilaritiesPK;

use strict;

############################################################
# Add any specific objects (GUSdev::) here
############################################################

use Objects::GUS_utils::GusApplication;
use Objects::GUS_utils::BulkSimilarity;

my $Cfg;  ##global configuration object....passed into constructor as second arg

sub new {
	my $Class = shift;
	$Cfg = shift;  ##configuration object...

	return bless {}, $Class;
}

sub Usage {
	my $M   = shift;
	return 'Load in blast similarities generated by generateBlastSimilarity.pl  NOTE: Both query and subject must use primary key as identifier';
}

############################################################
# put the options in this method....
############################################################
sub CBIL::Util::EasyCspOptions {
	my $M   = shift;
	{

#		test_opt1 => {
#									o => 'opt1=s',
#									h => 'option 1 for test application',
#									d => 4,
#									l => 1,	ld => ':',
#									e => [ qw( 1 2 3 4 ) ],
#								 },
 subject_table     => {
											 o => 'subject_table=s',
											 h => 'subjects are taken from table',
											},

 log_frequency     => {
											 o => 'log_frequency=i',
											 h => 'Write line to log file once every this many entries',
											 d => 10,
											},

 query_table       => {
											 o => 'query_table=s',
											 h => 'queries are taken from this table',
											},

 files             => {
											 o => 'files=s',
											 h => 'read condensed results from this file',
											 l => 1,
											},

 nqueries          => {
											 o => 'nqueries=i',
											 h => 'process this many queries',
											 d => 1e6,
											},

 output            => {
											 o => 'output=s',
											 h => 'what type of similarity children to put in db',
											 d => 'both',
											 e => [ qw ( both summaries spans ) ],
											},

 restart           => {
											 o => 'restart=s',
											 h => 'restarts from last entry in Similarity....
                             takes list of row_alg_invocation_ids "234, 235"!',
											},
 update            => {
											 o => 'update!',
											 h => 'if true then updates existing Similarities rather than making new',
											},
 limit_sub => { o => 'limit_sub=i', h => 'maximum number of subjects to enter / query' },
 limit_hsp => { o => 'limit_hsp=i', h => 'maximum number of hsps to enter / subject' },

 ns_mi => { o => 'ns_mi=i', h => 'minimum number of subject filter' },
 ns_ma => { o => 'ns_ma=i', h => 'maximum number of subject filter' },

 su_pv => { o => 'su_pv=f', h => 'summary pvalue cutoff' },
 su_pi => { o => 'su_pi=f', h => 'summary percent identity cutoff' },
 su_ml => { o => 'su_ln=i', h => 'summary match length cutoff' },

 sp_pv => { o => 'sp_pv=f', h => 'span pvalue cutoff' },
 sp_pi => { o => 'sp_pi=f', h => 'span percent identity cutoff' },
 sp_ml => { o => 'sp_ln=i', h => 'span match length cutoff' },

	}
}


my $ctx;
my %ignore;
my %update;  ##queries with existing similarities to be updated...
my $countIgnored = 0;
my $subject_table_pk;
my $query_table_pk;
my $subject_table_id;
my $query_table_id;
my $queriesProcessed = 0;

$| = 1;

sub Run {
	my $M   = shift;
	$ctx = shift;

	die "LoadBlastSimilarities: you must provide a --subject_table and --query_table\n" unless ($ctx->{cla}->{subject_table} && $ctx->{cla}->{query_table});


		
	$ctx->{'self_inv'}->setMaximumNumberOfObjects(400000);

	##get the subject table_id
	$subject_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{ subject_table } );
	##and the query_table_id
	$query_table_id = $ctx->{ self_inv }->getTableIdFromTableName( $ctx->{cla}->{query_table} );
	##get the subject_table_pk
	$subject_table_pk = $ctx->{self_inv}->getTablePKFromTableId($subject_table_id);
	##now the query table pk..
	$query_table_pk = $ctx->{self_inv}->getTablePKFromTableId($ctx->{self_inv}->getTableIdFromTableName( $ctx->{query_table} ));

	eval("require GUS::Model::::$ctx->{'query_table'}");
	eval("require GUS::Model::::$ctx->{'subject_table'}");

	my $n_queries = 0;
	my $n_files   = 0;

	print $ctx->{'commit'} ? "*** COMMIT ON ***\n" : "*** COMMIT TURNED OFF ***\n";
	print "Testing on $ctx->{'testnumber'}\n" if $ctx->{'testnumber'};

	# open dbi database connection
##note that the login and password are coming from the gus_cfg file..
		my $dbh = $ctx->{'self_inv'}->getDbHandle();

		## want to be able to ignore entries already done!!
		if ($ctx->{'restart'}) {
			my $query = "select distinct query_id from Similarity where row_alg_invocation_id in ($ctx->{'restart'})";
			print "Restarting: Querying for the ids to ignore\n$query\n";
			my $stmt = $dbh->prepare($query);
			$stmt->execute();
			while ( my($id) = $stmt->fetchrow_array()) {
				$ignore{$id} = 1;
			}
			print "Ignoring ".scalar(keys%ignore)." entries\n";
		}

	##filters to pass into the Bulkloader module...
	my $filter_ns;
	$filter_ns->{ min }             = $ctx->{ ns_mi } if defined $ctx->{ ns_mi };
	$filter_ns->{ max }             = $ctx->{ ns_ma } if defined $ctx->{ ns_ma };

	my $filter_su;
	$filter_su->{ length          } = $ctx->{ su_ml } if defined $ctx->{ su_ml };
	$filter_su->{ pValue          } = $ctx->{ su_pv } if defined $ctx->{ su_pv };
	$filter_su->{ percentIdentity } = $ctx->{ su_pi } if defined $ctx->{ su_pi };

	my $filter_sp;
	$filter_sp->{ length          } = $ctx->{ sp_ml } if defined $ctx->{ sp_ml };
	$filter_sp->{ pValue          } = $ctx->{ sp_pv } if defined $ctx->{ sp_pv };
	$filter_sp->{ percentIdentity } = $ctx->{ sp_pi } if defined $ctx->{ sp_pi };

	my $filter_limit;
	$filter_limit->{subjects} = $ctx->{cla}->{limit_sub} if defined $ctx->{cla}->{limit_sub};
	$filter_limit->{hsps} = $ctx->{cla}->{limit_hsp} if defined $ctx->{cla}->{limit_hsp};

	# work through files in the list
 FILE_SCAN_LOOP:
foreach my $file ( @{ $ctx->{ files } } ) {

		$n_files++;

		# get an object to manage the file.
		my $bs = new BulkSimilarity( new CBIL::Util::A {
			file    => GetFileClever( $file ),
				query   => \&GetQueryObject,
					subject => \&GetSubjectTableAndSeqId,
						types   => $ctx->{ output },
					} )
			;

		#CBIL::Util::Disp::Display( $bs->{ parameters } );

		# parse into objects and submit to db
	SECTION_SCAN_LOOP:
		while ( my $o = $bs->getSectionObjects($filter_ns, $filter_su, $filter_sp, $filter_limit) ) {
			$n_queries++;
			#CBIL::Util::Disp::Display( $o );

			$o->submit();

			if($n_queries % ($ctx->{'log_frequency'} * 10) == 0){
				print join( "\t", $queriesProcessed, "$n_queries entered", $o->getId(), scalar $o->getSimilarityFacts,`date`);
			}elsif($n_queries % $ctx->{'log_frequency'} == 0){
				print join( "\t", $queriesProcessed, "$n_queries entered", $o->getId(), scalar $o->getSimilarityFacts)."\n";
			}

			$o->undefPointerCache();

			last FILE_SCAN_LOOP if $n_queries >= $ctx->{ nqueries };

		}														# eo similarities in file
	}															# eo filenames

	my $result = "Processed $queriesProcessed and loaded similarities for $n_queries from $n_files files";
	print "\n$result\n";
	return $result;
}

# given a source_id we return the query object..
## NOTE: using primary key so just create object and return it!!
sub GetQueryObject{
	my $Line = shift;
	$queriesProcessed++;
	# extract the query id from the defline
	$Line =~ /^\>*(\S+)\s\((\d+)/;
	return undef if $2 == 0;  ##there are no subjects for this one so don't bother retrieving from DB.
	my $id = $1;

	##want to ignore things that already have done!!
	if($ctx->{'restart'}){
		if(exists $ignore{$id}) {
			$countIgnored++;
			return undef;
		}
	}

	# get the query object 
	my $qObj = $ctx->{cla}->{query_table}->new( { $query_table_pk => $id } );

	if($qObj->retrieveFromDB()){  ##have object..
		$qObj->retrieveSimilarityFactsFromDB($ctx->{cla}->{subject_table}) if $ctx->{cla}->{update};
		return $qObj;
	}
	
	return undef;
}

##NOTE: we have the primary key already so just return expected....
sub GetSubjectTableAndSeqId {
	my $Id = shift;
	return undef unless $Id;
	return ( $subject_table_id, $Id );
}

# ----------------------------------------------------------------------

sub GetFileClever {
	my $F = shift;

	my $f;

	if ( $F =~ /\.gz$/ ) {
		$f = "gunzip -c $F|";
	}

	elsif ( $F =~ /\.Z$/ ) {
		$f = "zcat $F|";
	}

	elsif ( -f $F ) {
		$f = "<$F";
	}

	else {
		$f = GetFileClever( $F. '.gz' ) || GetFileClever( $F. '.gz' );
	}

	return $f;
}




1;

