<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
  <title>PERL Objects</title>
</head>
 <body>
  
<h1> <font size="+2">PERL Object Layer for Oracle or Sybase Relational DBMS</font></h1>
 <font size="+2">Description:</font> 
<p>The perl object layer on a relational dbms is intended to simplify database 
interactivity and manage relationships and submits.&nbsp; The query capability 
is currently very limited.&nbsp; Functionality includes: </p>
<ul>
 
  <li> Retrieving objects from database.</li>
  
  <li> Getting and Setting attribute values.</li>
  
  <li> Managing parent-child relationships (determined via foreign key constraints 
where the child is the object containing a foreign key pointer to the parent).&nbsp; 
Objects can always retrieve their parents and children.<br>
 <b><font color="#ff0000">NOTE:&nbsp; CURRENTLY THE OBJECTS MAY HAVE ONLY 
ONE PARENT OF A PARTICULAR TABLE/VIEW NAME.&nbsp; This means that the getParet/getChildren 
methods do not work where the child has two foreign key pointers back to the
same table/view.&nbsp; The exception to this is when the table is an&nbsp; 
imp table and the "parents" are different views of that table.&nbsp; In this
case, the specifics of the relationships must be specified in a special cases
file before generating the objects.</font></b></li>
  
  <li> Caching objects retrieved from Database so only one object for any
given tuple is present in memory at a time.</li>
  
  <li> Managing submits (inserts,updates and deletes)</li>
  
  <ul>
 
    <li> Automatically determines type of submit.</li>
  
    <li> Parents submit all their children recursively.</li>
  
    <li> Children only submit parents if parent does not have a primary key
(is new object that has not been submitted).&nbsp; Then parent is submitted 
but does not submit any children.</li>
  
    <li> Versioning happens automatically by default.</li>
  
    <li> Transaction management by default (methods to over-ride if necessary).</li>
  
    <li> Evidence and Similarity managed cleanly.</li>
  
    <li> Sets "default" attributes if set (row_user_id,row_alg_invocation_id,row_project_id,row_group_id 
and permissions).</li>
  
    <li> sequence_versions managed when new sequence string is set.</li>
 
  </ul>
  
  <li> XML functions for printing to XML and parsing XML into valid objects.</li>
  
  <li> Enforce read/write permissions on retrieval of parents and children.</li>
  
  <li> Provide functionality to set, get and submit Evidence.</li>
  
  <li> Simple comparison operators to determine if attributes match an object 
(or if an object has attributes that have been changed from db).</li>
  
  <li> Code generator to generate complete set of objects corresponding to
the database.</li>
 
</ul>
 <font size="+2">NOTE:&nbsp; There are many more methods in the superclasses 
including methods for querying (DbiTable) and getting meta data from the db.</font>
 
<p><font size="+2">Methods by functional groups: (<font color="#ff0000">the 
most useful methods are indicated in </font><font color="#ff1c27">red</font><font color="#000000">
).&nbsp; Most of the others are convenience methods or could be considered
private methods of the objects.</font></font> </p>
<hr width="100%" size="2" align="Left">
<p><b><a href="#DbiDatabase%20Methods">DbiDatabase login/logou</a>
t:&nbsp; Used to create database login which allows all subsequent functionality.</b>
 <br>
<b><a href="#Constructor">Constructor</a>
</b> <br>
<b><a href="#gets_sets">Getting and Setting attribute values</a>
</b> <br>
<b><a href="#retreiveFromDB">Retrieving objects from the database</a>
</b> <br>
<b><a href="#dbCache">Managing object cache</a>
</b> <br>
<b><a href="#Setting%20default%20values:">Setting default values</a>
</b> <br>
<b><a href="#max_objects">Increasing the maximum number of objects allowed
in RAM</a>
</b> <br>
<b><a href="#global_noversion">Setting global NO version</a>
</b> <br>
<b><a href="#instance_version">Instance level management of versioning and
updating:</a>
</b> <br>
<b><a href="#read_write_permissions">Checking read and write permissions</a>
</b> <br>
<b><a href="#global_behavior">Managing global behavior of objects</a>
</b> <br>
<b><a href="#memory_management">Managing memory (undefPointerCache!)</a>
</b> <br>
<b><a href="#parent_child_lists">Managing valid parents/children</a>
</b> <br>
<b><a href="#children">Managing Children</a>
</b> <br>
<b><a href="#parents">Managing Parents</a>
</b> <br>
<b><a href="#submits">Managing submits to database:</a>
</b> <br>
<b><a href="#deletes">Managing deletes</a>
</b> <br>
<b><a href="#Evidence">Evidence</a>
</b> <br>
<b><a href="#similarity_facts">Similarity facts for storing sequence similarities</a>
</b> <br>
<b><a href="#sequence_methods">Methods for dealing with sequence</a>
</b> <br>
<b><a href="#Printing">Printing</a>
</b> <br>
<b><a href="#xml">Parsing XML into objects</a>
</b> <br>
<b><a href="#att_values">Comparing attribute values</a>
</b> <br>
<b><a href="#table_ids">Retrieving table ids and primary key attributes given
name</a>
</b> <br>
<b><a href="#fact_methods">General methods for dealing with facts</a>
</b> <br>
<b><a href="#miscellaneous">Miscellaneous method<br>
</a>
</b><a href="#hand_coded"><b>Special objects (hand coded so have extra functionality).</b><br>
</a>
 </p>
<hr width="100%" size="2" align="Left">
<p><b><font size="+1">DbiDatabase Methods:&nbsp; Establish logins, retrieve
meta information:</font></b> </p>
<p><b>DbiDatabase is the module that is used to create logins to the database 
and from which all the other objects are generated.&nbsp; </b>Thus, to start
a session, you simply create a new DbiDatabase and you are then able to use
all the objects representing specific tables in that database.&nbsp; DbiDatabase
also has methods for getting meta information relevant to that database (such
as getTables()) in addition to getTable(tableName) which returns a DbiTable
for tableName.&nbsp; This enables users to access meta information for this
specific table such as foreign key relationships, primary key attributes,
etc.&nbsp; These methods, however, will in most cases be unecessary as the
Table specific objects take care of all this for the user. </p>
<p><font color="#ff0000">DbiDatabase-&gt;new( DBI_DSN, login,&nbsp; password, 
verbose,&nbsp; noInsert, default, dbName)</font> <br>
&nbsp;&nbsp;&nbsp; This creates a DbiDatabase that allows the use of all
the following methods on specific objects.&nbsp; DBI_DSN is optional if you
have your environment variable of this same name set.&nbsp; login, password,
and dbname are required where dbname is case sensitive such as "GUSdev".&nbsp;&nbsp;
Verbose if true prints all SQL statements executed and noInsert if true does
not commit to the database although all sql is executed and then rolled back.&nbsp;
The objects manage these attributes of the Database with setVerboseOn() and
setCommitOff() (<a href="#global_behavior">see below</a>
). </p>
<p><font color="#ff0000">DbiDatabase-&gt;logout()</font> <br>
&nbsp;&nbsp;&nbsp; Ends this session and disconnects all the handles generated. 
</p>
<p>Additional methods are available if needed to retrieve meta information 
from the database such as a listing of all the tables/views etc. </p>
<p><a name="Constructor"></a>
<b><font size="+1">Constructor:</font></b> </p>
<p><font color="#ff1119">TableName-&gt;new($dbiTableHashRef, $primary_key_list, 
$dbhandle)</font> <br>
&nbsp;&nbsp;&nbsp; This will create an object for TableName.&nbsp; All aguments
are optional.&nbsp; I normally only pass in the hash reference of attribute
values if I want to set some values this way.&nbsp; The primary key list
is only necessary if the table does not have a primary key defined (which
all GUS objects do) and dbhandle only if you are using a database that is
different than that logged into with the DbiDatabase constructor which establishes
the necessary database handles for the objects to interact with the database. 
</p>
<p><a name="gets_sets"></a>
<b><font size="+1">Getting and Setting attribute values:</font></b> <br>
Attribute values can be set in two ways.&nbsp; The first is by passing in
a hash ref of attribute =&gt; value pairs to the constructor.&nbsp; The second
is via set methods in each object of the form: </p>
<p><font color="#ff0a16">setRowUserId($userId);</font> for the attribute "row_user_id". 
</p>
<p>Alternatively, one can use the set method in the super class directly.
&nbsp; &nbsp;<b>NOTE: </b>this is in general not a good idea as this bypasses
any specific functionality that may be associated with the set method of
the specific objects. &nbsp;For instance, the setSequence method of the sequence
objects removes returns, uppercases all characters &nbsp;and sets &nbsp;the
length attribute so there is a consistent representation in the db. </p>
<p><font color="#ff1119">set('row_user_id',$userId)</font>; </p>
<p>Get methods follow this same syntax except do not take in the value but
rather return it. </p>
<p><font color="#ff0a0e">getRowUserId()</font> </p>
<p><font color="#ff0a0e">get('row_user_id')</font></p>
<p><font color="#ff0a0e"><font color="#330033">Getting substrings from &nbsp;CLOB
attribute types. &nbsp;This is particularly useful if one hasn't retrieved
the CLOB attribute (see below) to save retrieving a very long sequence, for
example, into memory. &nbsp;The method is a generic one to allow retrieving
substrings from any CLOB attribute:</font></font></p>
<p><font color="#ff0a0e"><font color="#330033"><font color="#ff0000">getSubstrFromClob($attribute,$start,$length)
&nbsp;<font color="#330033">Note that the start here is indexed from 1. &nbsp;To
retrieve a sequence substring from a sequence object one would use<br>
&nbsp;&nbsp;&nbsp; $sequence-&gt;getSubstrFromClob('sequence',2334,1000)
#would retrieve 1000 characters from the sequence &nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; attribute starting at position 2334.<br>
</font></font><br>
</font><br>
</font> </p>
<p><a name="retreiveFromDB"></a>
<b><font size="+1">Retrieving objects from the database:</font></b> <br>
Enough attributes must be set to ensure a single row is retrieved. </p>
<p><font color="#ff0c14">retrieveFromDB(\@attributesToNotRetrieve,$replaceCache)</font>
 <br>
&nbsp;&nbsp;&nbsp; returns 1 if successful and populates the objects attribute
values from the database.&nbsp; If unsuccessful returns 0 and leaves object
unaffected.&nbsp; If multiple rows are returned then is considered unsuccessful.&nbsp;
The query to the database simply constrains all the attributes that have
been set. &nbsp;One can choose to NOT retrieve specific attributes by passing
in an array reference of attribute names that should not &nbsp;be retrieved.
&nbsp;This can be extremely useful for objects that have very large atts
such as sequence if one only wants other attributes or just a substring from
the sequence (see previous command). </p>
<p><a name="dbCache"></a>
<b><font size="+1">Managing Object Database Cache:</font></b> <br>
Objects are cached when retrieved from the database either with retrieveFromDB 
or getParent/Children methods.&nbsp; In the case of getParent/Children, if
an object is requested that is already in the cache, the object in the cache
is returned/added so that only a single object representing the tuple is
present at any given time.&nbsp; RetrieveFromDB always retrieves the object
from the database even if there is already a copy in the cache and replaces
the current cached copy if the optional $replaceCache variable is used.&nbsp; 
Users should check the cache to see if an object already exists before retrieving
from the db if there is a chance that they are constructing duplicate objects.&nbsp;&nbsp;
<b>NOTE:&nbsp;</b> the key of the cache is a concatenated string of the primary
key values.&nbsp; This is generated by the method getConcatPrimKey().&nbsp;
In most cases (when there is a single primary key attribute) this will be
just the value of the identifier returned by getId(). </p>
<p>addToDbCache($o,$replace) <br>
&nbsp;&nbsp;&nbsp; adds objects to cache...this is done automatically when
objects are retrieved from the database so shouldn't be called by users. </p>
<p><font color="#ff0000">getFromDbCache($class,$key)</font> <br>
&nbsp;&nbsp;&nbsp; returns the object if it exists else undef. </p>
<p><font color="#ff0000">isInDbCache($class,$key)</font> <br>
&nbsp;&nbsp;&nbsp; returns 1 if in the cache and undef otherwise.&nbsp;&nbsp; 
Note for testing purposes this is very similar to getFromDbCache. </p>
<p>removeFromDbCache($object) <br>
&nbsp;&nbsp;&nbsp; removes the object ($object) from the dbCache. </p>
<p><a name="Setting default values:"></a>
<b><font size="+1">Setting default values:</font></b> <br>
These methods are used for setting default values which all subsequent objects
created in the application will inherit. On submit these values will be set&nbsp;
automatically. </p>
<p>setDefaultProjectId($project_id) (default = 0 (GUS)) <br>
getDefaultProjectId() <br>
<font color="#ff0c14">setDefaultUserId($id)</font> <br>
getDefaultUserId() <br>
setDefaultGroupId($id)&nbsp; (default = CBIL) <br>
getDefaultGroupId() <br>
<font color="#ff0a12">setDefaultAlgoInvoId($id)</font> <br>
getDefaultAlgoInvoId() <br>
setDefaultUserRead($read)&nbsp; (default = 1) <br>
getDefaultUserRead() <br>
setDefaultUserWrite($val)&nbsp; (default = 1) <br>
getDefaultUserWrite() <br>
setDefaultGroupRead($val)&nbsp; (default = 1) <br>
getDefaultGroupRead() <br>
setDefaultGroupWrite($val)&nbsp; (default = 1) <br>
getDefaultGroupWrite() <br>
setDefaultOtherRead($val)&nbsp; (default = 1) <br>
getDefaultOtherRead() <br>
setDefaultOtherWrite($val)&nbsp; (default = 0) <br>
getDefaultOtherWrite() </p>
<p><a name="max_objects"></a>
<b><font size="+1">Increasing the maximum number of objects allowed in RAM
at one time (default is 10000):</font></b> <br>
This method is necessary to prevent memory leaks due to forgetting to call
undefPointerCache() in each loop to release objects for garbage collection.&nbsp;
Unless the user needs more than 10000 objects at one time (which seems very
unlikely) then these methods should be uneccessary. </p>
<p>setMaximumNumberOfObjects($num) <br>
getMaximumNumberOfObjects() </p>
<p><a name="global_noversion"></a>
<b><font size="+1">Setting global NO version (default = 0):</font></b> <br>
While this functionality defies the initial design of GUS, it is needed for
dealing with things like draft sequence where one wants to simply wipe the
database of the current version and replace it with something new.&nbsp; No
objects are versioned. </p>
<p>setGlobalNoVersion($val) <br>
getGlobalNoVersion() </p>
<p><a name="instance_version"></a>
<b><font size="+1">Instance level management of versioning and updating:</font></b>
 <br>
Indvidual objects can be specified to be not versioned or not updateable.&nbsp; 
Default is to version and allow updates for all objects. </p>
<p>setVersionable($v) (default = 1) <br>
isVersionable() <br>
setUpdateable($u) (default = 1) <br>
isUpdateable() </p>
<p><a name="read_write_permissions"></a>
<b><font size="+1">Checking read and write permissions:</font></b> <br>
Methods to check the read/write permissions based on the default group and
user.&nbsp; Enforced when retrieving from database or retrieving children
or parents. </p>
<p>checkReadPermission() <br>
checkWritePermission() </p>
<p><a name="global_behavior"></a>
<b><font size="+1">Managing global behavior of objects (commit, verbose,
debug):</font></b> <br>
These parameters (once set) take affect on all objects.&nbsp; Defaults:&nbsp; 
commit = on, verbose = off, debug = off. </p>
<p><font color="#ff0c29">setDebuggingOn()</font> <br>
&nbsp;&nbsp;&nbsp; Reports debug statements for methods in RelationalRow. 
<br>
setDebuggingOff() <br>
getDebuggingState() </p>
<p><font color="#ff0a12">setVerboseOn()</font> <br>
&nbsp;&nbsp;&nbsp; Turns on printing to stdout all SQL statements. <br>
setVerboseOff() <br>
getVerboseState() </p>
<p><font color="#ff020b">setCommitOff()</font> <br>
&nbsp;&nbsp;&nbsp; All submits will be rolled back rather than committed.&nbsp; 
Should not be turned off except for testing on a few loops. <br>
setCommitOn() <br>
getCommitState() </p>
<p><a name="memory_management"></a>
<b><font size="+1">Managing memory (allowing garbage collection of objects
that are out of scope):</font></b> <br>
Necessary because of perls lack of a garbage collector that can deal with
circular references.&nbsp; Only method really necessary as all others are
automatically taken care of is undefPointerCache() which must be called in
each loop. Note that this removes all objects from the pointer cache so all
parent/child relationships are lost and must be re-established if needed. 
</p>
<p>removeAllChildPointers($recursive) <br>
&nbsp;&nbsp;&nbsp; If $recursive = 1 then will call method on all children 
recursively.&nbsp;</p>
<p>addToPointerCache($ob) <br>
&nbsp;&nbsp;&nbsp; Add objects to the pointer cache....done automatically 
when objects are created rarely if ever needs to be called. <br>
getFromPointerCache($object_reference) <br>
&nbsp;&nbsp;&nbsp; Method to retrieve the object from the pointer cache. <br>
removeFromPointerCache($ob) <br>
&nbsp;&nbsp;&nbsp; Removes single object from the cache. <br>
<b><font color="#ff0a16">undefPointerCache()</font></b> <br>
&nbsp;&nbsp;&nbsp; <font color="#ff0000"><b>MUST </b></font><font color="#ff0000">
be called in each loop to allow garbage collection.&nbsp; Removes all child
and parent pointers so they can not be retrieved.</font> </p>
<p><a name="parent_child_lists"></a>
<b><font size="+1">Managing valid parents/children (code generator takes
care of this).</font></b> <br>
The objects keep a list of valid parents and children.&nbsp; Assuming the
code generator is working correctly, these methods should not need to be
used. </p>
<p>setChildList(@list) <br>
&nbsp;&nbsp;&nbsp; @list is an array of array references [ChildTableName,My_primary_key,Childs_foreign_key_to_me] 
<br>
addToChildList(@list) <br>
getChildList() <br>
isValidChild($c) <br>
isOnChildList($className) <br>
getChildSelfColumn($className) <br>
getChildColumn($className) </p>
<p>setParentList(@list) <br>
addToParentList(@list) <br>
getParentList() <br>
getParentSelfColumn($className) <br>
getParentColumn($className) <br>
isValidParent($p) <br>
isOnParentList($className) </p>
<p>set255ChildList(@list) <br>
addTo255ChildList(@list) <br>
get255ChildList() <br>
get255ChildListPkAtt($className) <br>
get255ChildListOrderAtt($className) <br>
get255ChildListStringAtt($className) <br>
isValid255ChildName($className) </p>
<p><a name="children"></a>
<b><font size="+1">Managing Children (objects with my primary key as a foreign
key):</font></b> <br>
Methods for managing children including retrieving from the database, getting
(returning children) marking children deleted and submitting.&nbsp; NOTE
that submitting children is automatically done whenever an object is submitted
and should be unecessary (in fact the methods for managing the transaction
may NOT work appropriately if one submits children manually).&nbsp; Submitting
self results in submitting self &nbsp;and then all children within a single 
transaction. </p>
<p><b>getChildren or retrieveChildrenFromDB with one of the ImpClasses will
bring back the appropriate subclass children/parent of that ImpClass. </b>
For example: getChildren('NAFeatureImp',1) will get any of the NAFeature
subclass children such as RNAFeature, GeneFeature, ExonFeature etc.&nbsp;
In this way, one can retrieve all the features associated with a given NASequence 
entry. </p>
<p><font color="#ff0a12">getChildren($className, $retrieveIfNoChildren, $getDeletedToo,
$where,\@doNotRetrieveAttributes)</font> <br>
&nbsp;&nbsp;&nbsp; Returns an array of children in classname.&nbsp; If $retrieveIfNoChildren
= 1 then does a retrieveFromDB if there are currently no children of this
className.&nbsp; If $getDeletedToo = 1 then will also return children that
have been marked deleted.&nbsp; $where is a hash ref where children returned
must meet all the attribute (key) =&gt; value (value) pairs in the hashref.&nbsp;
If the $className is one of the "Imp" tables such as NASequenceImp, then
the subclass objects of the correct type are returned....ie ExternalNASequence,
Assembly as appropriate. &nbsp;The last argument is an array reference of
attbibutes that should not be retrieved should these children need to be
retrieved from the DB...ie $retrieveIfNoChildren = 1. </p>
<p><font color="#ff0000">getAllChildren($retrieve, $getDeletedToo, $where)</font>
 <br>
&nbsp;&nbsp;&nbsp; Returns all children. </p>
<p>getChild($className, $retIfNochildren, $getDeletedToo) <br>
&nbsp;&nbsp;&nbsp; Returns one child (<b>NOTE:</b> only useful if you know
there is only one child as returns the first one on the list if more than
one). </p>
<p>setChild($c) <br>
&nbsp;&nbsp;&nbsp; <b>Replaces </b>children in this childs class with this 
child.&nbsp; Should use <font color="#ff0000">addChild </font>for adding
children. </p>
<p><font color="#ff0a12">retrieveChildrenFromDB($className, $resetIfHave, 
$where</font><font color="#ff0000">,\@doNotRetrieveAttributes</font><font color="#ff0a12">
)</font> <br>
&nbsp;&nbsp;&nbsp; Retrieves children in $className from the database.&nbsp; 
If $resetIfHave = 1 will reset any children that you already have to the values
from the database.&nbsp; NOTE that any relationships established on the children
that are reset will be lost.&nbsp; $where hash ref as for getChildren().&nbsp;
Note that using getChildren($className,1) will call retrieveChildrenFromDB
if they have not already been retrieved and so save a step. </p>
<p>resetChildrenToDB($className, $where) <br>
&nbsp;&nbsp;&nbsp; Removes all the children with this className and retrieves
them fresh from the db. </p>
<p><font color="#ff0a12">retrieveAllChildrenFromDB($recursive, $resetIfHave)</font>
 <br>
&nbsp;&nbsp;&nbsp; Retrieves all this objects children.&nbsp; If $recursive 
= 1 will do this recursively.&nbsp; NOTE that this has the potential for retrieving
a huge number of objects if called from something like Group.&nbsp; $resetIfHave
resets children you already have to the database. </p>
<p>resetAllChildrenToDB() <br>
&nbsp;&nbsp;&nbsp; Retrieves all children following removal of all existing
ones. </p>
<p><font color="#ff0c0c">addChild($c, $resetIfHave)</font> <br>
&nbsp;&nbsp;&nbsp; Method of choice for adding a child. </p>
<p>addChildren(@children) <br>
&nbsp;&nbsp;&nbsp; Adds an array of children. </p>
<p>removeChild($c) <br>
&nbsp;&nbsp;&nbsp; Remove child from self.&nbsp; NOTE that this has NO impact
on the database....simply removes pointer between parent and child. </p>
<p>removeChildren(@ch) </p>
<p>removeChildrenInClass($className) </p>
<p>removeAllChildren() <br>
&nbsp; <br>
&nbsp; </p>
<p><a name="parents"></a>
<b><font size="+1">Managing Parents:</font></b> <br>
Similar to managing children.&nbsp; Difference is that can only have one
parent of each type. </p>
<p><font color="#ff0c0c">setParent($p)</font> <br>
&nbsp;&nbsp;&nbsp; Sets this object as my parent.&nbsp; The parent likewise
points to me as its child. &nbsp;Thus calling $p-&gt;addChild($self) is equivalent
to $self-&gt;setParent($p) </p>
<p><font color="#ff0a0a">getParent($className, $retrieveIfNoParent</font><font color="#ff0000">
,\@doNotRetrieveAttributes</font><font color="#ff0a0a">)</font> <br>
&nbsp;&nbsp;&nbsp; if $retrieveIfNoParent = 1 then calls retrieveParentFromDB 
if does not have that parent.&nbsp; If the $className is one of the "Imp" 
tables such as NASequenceImp, then the subclass objects of the correct type
are returned....ie ExternalNASequence, Assembly as appropriate. </p>
<p>getAllParents(<font color="#000000">$retrieveIfNoParent,\@doNotRetrieveAttributes</font>
) </p>
<p><font color="#ff0c0c">retrieveParentFromDB($className</font><font color="#ff0000">
,\@doNotRetrieveAttributes</font><font color="#ff0c0c">)</font> </p>
<p>retrieveAllParentsFromDB() </p>
<p>setParentId($p) <br>
&nbsp;&nbsp;&nbsp; Sets my foreign key to be the Id of this parent.&nbsp; 
Note that this occurs automatically upon submit to the database. </p>
<p>removeParent($p) </p>
<p>removeAllParents() </p>
<p><a name="submits"></a>
<b><font size="+1">Managing submits to database:</font></b> <br>
Principal here is that the top level object (an object with only children) 
should be submitted.&nbsp; That object following submitting itself, will submit
all its children recursively.&nbsp; Simple many-to-many relationships are
traversed in order to set the foreign keys of the relation, however, the
parent on the far side of the relation will not submit any of its children.&nbsp; 
All objects submitting with a single submit command are submitted in a single
transaction so that if something fails, all are rolled back together to mantain
database integrity.&nbsp; All tuples that are updated are versioned by default
and sequences are stored (and versioned) appropriately.&nbsp; Evidence&nbsp;
and Similarity facts are also submitted if they have been set (added).&nbsp;
Upon delete, all Evidence and Similarity tuples that relate to the object
are also deleted (and versioned of course!). &nbsp;Additionally, objects
can store other objects to be &nbsp;submitted after they have submitted themselves
and all their children via the method addToSubmitList($object). </p>
<p>Note that submit and perhaps manage transaction are the only methods in
this group that need to be called by user.&nbsp; The others are automatically 
taken care of appropriately. </p>
<p><font color="#ff0a12">submit($notDeep, $noTran)</font> <br>
&nbsp;&nbsp;&nbsp; Automatically submits inside a transaction.&nbsp; $notDeep
= 1 only submits self but not children.&nbsp; $noTran = 1 does not begin
or (when finished) commit a transaction.&nbsp; Used by all children so are
submitted in the initial objects transcation. </p>
<p><font color="#ff0a12">manageTransaction($noTran, $task)</font> <br>
&nbsp;&nbsp;&nbsp; This is dealt with automatically, However, if one wants
to submit several top level objects in a single transaction, you can use
manageTransaction to start and then commit a transaction and submit with
noTran the objects in between.&nbsp; $task is either 'commit' or 'begin'.</p>
<p><font color="#ff0000">addToSubmitList($object)</font><br>
&nbsp;&nbsp;&nbsp; Add $object to a submit list so that it gets submitted
after I submit myself and all children (in the same transaction). &nbsp;This
is the best way to submit objects on far side of a many-to-many relation
&nbsp;that have children and thus need to be submitted explicitly.<br>
 </p>
<p>setRollBack($rb) <br>
&nbsp;&nbsp;&nbsp; This can be used during an update/submit to force a roll
back at end of submit if errors are detected. </p>
<p> </p>
<p>submitEvidence($e, $notDeep, $noTran) </p>
<p>submitAllEvidence($notDeep, $noTran) </p>
<p>deleteAllEvidence($notDeep, $noTran) </p>
<p>submitSimilarityFact($fact, $notDeep, $noTran) </p>
<p>submitAllSimilarityFacts($notDeep, $noTran) </p>
<p>deleteSimilarityFact($f, $notDeep, $noTran) </p>
<p>deleteAllSimilarityFacts($notDeep, $noTran) <br>
&nbsp;&nbsp;&nbsp; All similarity facts of an object are deleted upon submit
if that object has been marked deleted. </p>
<p>submitAllChildren() </p>
<p>submitChildren() </p>
<p>submitChildrenInClass($className) </p>
<p>setAllForeignKeys() </p>
<p>allNonNullsSet() </p>
<p>version() </p>
<p>getVersionTableName() </p>
<p>getRollBack() </p>
<p>setDefaultAttributes() <br>
&nbsp;&nbsp;&nbsp; Sets all the attributes for which defaults have been set. 
</p>
<p><a name="deletes"></a>
<b><font size="+1">Managing deletes:</font></b> <br>
Deletes occur in two phases.&nbsp; Objects must first be marked for deletion
at wich time they can only be retrieved (with getChildren) if one adds in
the bit to getDeletedToo.&nbsp; Objects are deleted from the database (and
versioned) when submitted.&nbsp; Note that in order to delete a tuple, all
it's foreign key relations (children) must also be marked deleted.&nbsp;
The retrieveAllChildrenFromDB(1) and markDeleted(1) are recursive to facillitate
this process. </p>
<p><font color="#ff1420">markDeleted($doChildren)</font> <br>
&nbsp;&nbsp;&nbsp; Mark self deleted.&nbsp; It $doChildren = 1 then does
this recursively. </p>
<p>isMarkedDeleted() <br>
&nbsp;&nbsp;&nbsp; Returns 1 if object is marked deleted. </p>
<p>markUnDeleted() </p>
<p>markChildDeleted($c) <br>
&nbsp;&nbsp;&nbsp; Mark this child deleted so will be removed from the database
on submit. </p>
<p>markChildrenInClassDeleted($className) <br>
&nbsp;&nbsp;&nbsp; Mark all children in this class deleted. </p>
<p>markChildrenDeleted(@ch) <br>
&nbsp;&nbsp;&nbsp; Mark each of these children deleted. </p>
<p>markAllChildrenDeleted($recursive) <br>
&nbsp;&nbsp;&nbsp; Mark all the children I have deleted....recursively if
$recursive = 1. </p>
<p>markChildUnDeleted($c) <br>
&nbsp;&nbsp;&nbsp; Undelete child previously marked deleted. </p>
<p>markChildrenInClassUnDeleted($className) </p>
<p>markChildrenUnDeleted(@ch) </p>
<p>markAllChildrenUnDeleted() </p>
<p><a name="Evidence"></a>
<b><font size="+1">Evidence:</font></b> <br>
Methods that allow setting and retrieving Evidence.&nbsp; Evidence gets submitting
automatically by "target" object. </p>
<p><font color="#ff0a12">addEvidence($fact, $evidence_group_id, $attribute_name)</font>
 <br>
&nbsp;&nbsp;&nbsp; $fact is a fact object.&nbsp; Can optionally pass in an
evidence group id to group relevant evidence such as for a gene model one
might group the evidence for all the exons.&nbsp; Also optional is the attribute_name
if the evidence is for a particular attribute of the target table such as
"name" or "description". </p>
<p><font color="#ff0c10">getEvidence($factTableName, $retrieveUnlessHave)</font>
 <br>
&nbsp;&nbsp;&nbsp; This method returns an array of Evidence objects.&nbsp; 
One can retrieve the fact associated with each with EvidenceObj-&gt;getEvidenceFact(1); 
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; note that the optional argument 
1 causes the fact object to be retrieved from the database if this has not
already been done. </p>
<p>getEvidenceByGroupId($factTableName, $retrieveUnlessHave) <br>
&nbsp;&nbsp;&nbsp; method untested. </p>
<p>retrieveEvidenceFromDB($factTableName, $resetIfHave) </p>
<p><font color="#ff0000">retrieveAllEvidenceFromDB($resetIfHave, $targetOrFact)</font>
 <br>
&nbsp;&nbsp;&nbsp; Retrieves all the evidence for this object.&nbsp; It $targetOrFact
then will retrieve whether this object is the target table or fact table.&nbsp;
Default behaviour is to only retrieve evidence if target table.&nbsp; Use
getEvidence then to return an array of evidence ojbects. </p>
<p>retrieveEvidenceFactsFromDB($evidence, $resetIfHave) </p>
<p>getAllEvidence() </p>
<p><a name="similarity_facts"></a>
<b><font size="+1">Similarity facts for storing sequence similarities:</font></b>
 <br>
Methods for dealing with Similarity facts generated by blast and perhaps other
sequence similarity algorithms. </p>
<p><font color="#ff0a1a">addSimilarityFact($fact, $resetIfHave)</font> </p>
<p><font color="#ff0710">getSimilarityFacts($getIfDontHave)</font> </p>
<p>retrieveSimilarityFactsFromDB($subjectTableName, $getEitherWay, $resetIfHave) 
<br>
&nbsp; </p>
<p><a name="sequence_methods"></a>
<b><font size="+1">Methods for dealing with sequence:</font></b> <br>
Get, set, and format sequence. </p>
<p><font color="#ff020f">getSequence()</font> <br>
Returns the sequence as single string. </p>
<p><font color="#ff0c0c">setSequence($sequence)</font> <br>
Takes sequence string, cleans it up a bit (removes returns and non-sequence
characters) and then sets. </p>
<p><font color="#ff0000">getFeatureSequence()</font> <br>
&nbsp;&nbsp;&nbsp; All features support this method which retrieves the sequence
corresponding to that feature.&nbsp; Basically retrieves a substring from
the sequence to which the feature points corresponding to the span of the
feature on the sequence.&nbsp; RNAFeature generates the sequence from the
exons which make it up if it is predicted unless the actual sequence is stored
in SplicedNASequence. &nbsp;NOTE that this method retrieves the sequence
object to which it points without retrieving the sequence attribute. &nbsp;getSubstrFromClob
is then used to extract the relevant substring, thus saving much memory in
the case of very long sequences. </p>
<p><font color="#ff0714">toFasta($type)</font> <br>
Returns fasta formatted sequence.&nbsp; If $type = 1 the id used is the na_sequence_id
(or aa_sequence_id)&nbsp; otherwise it is the source_id. </p>
<p><a name="Printing"></a>
<b><font size="+1">Printing:&nbsp; (returns a string that can be printed)</font></b>
 <br>
Facility for printing to a string format or to XML. </p>
<p><font color="#ff0000">toString()</font> <br>
&nbsp;&nbsp;&nbsp; Returns in a simple string format the table object (does
not indicate parent or child relationshps). </p>
<p><font color="#ff0c10">toXML($indent, $suppressDef, $doXmlIds, $family)</font>
 <br>
&nbsp;&nbsp;&nbsp; If $suppressDef = 1 then the default attributes below modification_date
are suppressed.&nbsp; $doXmlIds = 1 will print XML ids in the object tags.&nbsp;
$family = 1 will print parent/child relationships in object tags rather than
nesting children (I think?). </p>
<p><a name="xml"></a>
<b><font size="+1">Parsing XML into objects:</font></b> </p>
<p><font color="#ff0c0c">parseXML($xml)</font> <br>
&nbsp;&nbsp;&nbsp; Objects parse the xml themselves... $xml is an array reference
where each line of the XML is an element. </p>
<p>processXmlAttributes($xml_atts) </p>
<p>getNextXmlId() </p>
<p>getXmlId() </p>
<p>setXmlId($id) </p>
<p>getObjectFromXmlId($xml_id) </p>
<p><a name="att_values"></a>
<b><font size="+1">Comparing attribute values:</font></b> <br>
An object can do simple checks given a hash reference (attributename =&gt;
value) to see if all the values match ones in the object.&nbsp; Likewise, 
an object can take in an object with the same (or a subset of) atributes set
and test for equivalence. </p>
<p>compareValues($v1, $v2, $type) </p>
<p><font color="#ff0710">testAttributeValues($href)</font> <br>
&nbsp;&nbsp;&nbsp; Test to see if all attribute =&gt; value pairs of the hash
reference match my values. </p>
<p><font color="#ff0c14">testObjectAttributeValues($ob)</font> <br>
&nbsp;&nbsp;&nbsp; Self test to see if all attributes of $ob match values
of self.&nbsp; Returns 1 if successful. </p>
<p><font color="#ff0000">getAttributeDifferences($ob)</font> <br>
&nbsp;&nbsp;&nbsp; For comparing two objects...pass in the smaller object
and $self will&nbsp; compare all attributes to see if values are same.&nbsp;
Returns an array of attribute names that are different. </p>
<p><a name="table_ids"></a>
<b><font size="+1">Retrieving table ids and primary key attributes given
name:</font></b> <br>
For getting the ids and table names from the Evidence and Similarity (mongo
many to many) tables. </p>
<p>getTableNameHash() </p>
<p><font color="#ff0a16">getTableNameFromTableId($table_id)</font> <br>
&nbsp;&nbsp;&nbsp; Returns the table name for $table_id. </p>
<p><font color="#ff0a16">getTableIdFromTableName($tableName)</font> <br>
&nbsp;&nbsp;&nbsp; Returns the table_id for $tableName. </p>
<p><font color="#ff0a16">getTablePKFromTableId($table_id)</font> <br>
&nbsp;&nbsp;&nbsp; Returns the primary key attribute for $table_id. </p>
<p><a name="fact_methods"></a>
<b><font size="+1">General methods for dealing with facts:</font></b> <br>
<b>Have NOT been tested and likely do not work...debug if you want to use!!</b>
 </p>
<p>getFacts($factTableName) </p>
<p>getAllFacts() </p>
<p>addFact($fact) </p>
<p>submitFact($fact, $notDeep, $noTran) </p>
<p>submitAllFacts($notDeep, $noTran) </p>
<p><a name="miscellaneous"></a>
<b><font size="+1">Miscellaneous methods:</font></b> </p>
<p><font color="#ff0c14">getClassName()</font> <br>
&nbsp;&nbsp;&nbsp; Returns class name (table name) of self. </p>
<p>getConcatPrimKey() <br>
&nbsp;&nbsp;&nbsp; returns the values of the primary key attributes concatentated
into a string.&nbsp; Used by the dbCache as not all objects have a single
attribute primary key. </p>
<p>haveAllPrimaryKeyValues() </p>
<p><font color="#ff0710">isValidAttribute($att)</font> <br>
&nbsp;&nbsp;&nbsp; Returns 1 if $att is a valid attribute of self. </p>
<p><font color="#ff0710">getDatabase()</font> <br>
&nbsp;&nbsp;&nbsp; returns the DbiDatabase object from which one can get
the extent and instance handles (and thus do queries) with the methods: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getDbHandle() ##handle all objects
use to interact with the DB. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getMetaDbHandle() ##handle that
retrieve meta information from DB. </p>
<p><font color="#ff0a0a">getQueryHandle($autocommit)</font> <br>
&nbsp;&nbsp;&nbsp; Returns a Dbi database handle that does not interfere with
the objects as may be the case with the above methods.&nbsp; If $autocommit
is true, then the handle autocommits on submit to the db. &nbsp;You always 
get the same handle as it is cached so if you need yet another handle you 
can get it from DbiDatabase with: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getDatabase()-&gt;makeNewHandle($autocommit) 
</p>
<p><font color="#ff0000">getTotalUpdates()</font> <br>
&nbsp;&nbsp;&nbsp; returns the total number of rows updated in this session. 
</p>
<p><font color="#ff0000">getTotalInserts()</font> <br>
&nbsp;&nbsp;&nbsp; returns the total number of rows inserted in this session. 
</p>
<p><font color="#ff0000">getTotalDeletes()</font> <br>
&nbsp;&nbsp;&nbsp; returns the total number of rows deleted in this session. 
<br>
&nbsp;<br>
<big><b><a name="hand_coded"></a>
Hand coded objects with extra functionality</b></big>...only a few are mentioned..</p>
<p>A number of the objects for GUS have been handcoded to have extra functionality.
&nbsp;A couple of these have been mentioned earlier. &nbsp;For example, sequence
objects (and &nbsp;all subclasses) have setSequence methods that clean up
the sequence on submit. &nbsp;Also, all Feature objects have getFeatureSequence()
methods.</p>
<p><b>NASequence and all subclasses:</b></p>
<p><font color="#ff0000">setSequence($sequenceString)</font><br>
&nbsp;&nbsp;&nbsp; cleans up the sequence a bit before setting.</p>
<p><font color="#ff0000">toFasta($type)</font><br>
&nbsp;&nbsp;&nbsp; returns the sequence in fasta format. &nbsp;It $type ==
1, uses the source_id for the primary identifier, otherwise uses the na_sequence_id.</p>
<p>toCAML()<br>
&nbsp;&nbsp;&nbsp; returns the sequence entry in CAML format (from Paracel
as input into CAP4).<br>
</p>
<p><b>(NA|AA)Feature and all subclasses:</b></p>
<p><font color="#ff0000">getFeatureSequence()</font><br>
&nbsp;&nbsp;&nbsp; returns the sequence for the feature.</p>
<p>getFeatureLocation()<br>
&nbsp;&nbsp;&nbsp; gets the location of this feature as an array (startLocation,
endLocation, is_reversed)</p>
<p><b>Assembly and AssemblySequence</b></p>
<p>These objects have many methods for manipulating assemblies and AssemblySequences
from parsing cap2/cap4 output &nbsp;to reverseComplementing and generating
&nbsp;cap2 alignments. &nbsp;Also has methods for computing/retrieving from
the database putative SNPs. &nbsp;Only a few will be indicated here...users
should look at the object (Objects/GUSdev/hand_edited/Assembly.pm) for more
complete info.</p>
<p><font color="#ff0000">Assembly-&gt;getCap2Alignment($idType,$suppressNumbers,$print)</font><br>
&nbsp;&nbsp;&nbsp; returns a cap2 format alignment for the assembly object.
&nbsp;$idType if true uses source_ids for the assembly sequences rather than
assembly_sequence_ids. &nbsp;if $suppressNumbers, does not print the locations
on the right margin. &nbsp;If $print, prints to STDOUT the alignment as it
is being generated....useful for very large assemblies as it &nbsp;starts
printing very quickly.</p>
<p><font color="#000000">Assembly-&gt;</font><font color="#000000">getRNA($retrieve,$getDeletedToo)</font><font color="#000000"><br>
</font><font color="#000000">&nbsp;&nbsp;&nbsp; returns the RNA associated
with this assembly.</font></p>
<p><font color="#000000">Assembly-&gt;</font><font color="#000000">ge</font>
tTranslatedAASequences($retrieve,$getDeletedToo)<br>
&nbsp;&nbsp;&nbsp; returns an array of TranslatedAASequences</p>
<p><b>Similarity:</b></p>
<p><font color="#ff0000">setPValue($pValue)</font><br>
&nbsp;&nbsp;&nbsp; sets the pvalue given the actual pvalue (separates it
into pvalue_mant and exp.</p>
<p><font color="#ff0000">getPValue()</font><br>
&nbsp;&nbsp;&nbsp; returns the actual P Value</p>
<p><font color="#ff0000">generateSimilarityAlignment($type)</font><br>
&nbsp;&nbsp;&nbsp; returns an alignment &nbsp;for each HSP (SimilaritySpan)
generated using $type algorithm where the algorithm is ([blast]|fasta|sim4)
with blast being the default.<br>
 </p>
<hr width="100%" size="2" align="Left">
<p><b>Last updated: Wed Oct 24 15:19:58 EDT 2001</b> </p>
</body>
</html>
