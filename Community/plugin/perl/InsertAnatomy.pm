#######################################################################
##           InsertAnatomy.pm
##
##
#######################################################################

package GUS::Community::Plugin::InsertAnatomy;
@ISA = qw(GUS::PluginMgr::Plugin);

use strict;

use FileHandle;
use GUS::PluginMgr::Plugin;
use GUS::Model::SRes::Anatomy;
use GUS::Model::SRes::ExternalDatabaseRelease;
use GUS::Model::SRes::ExternalDatabase;

my $purposeBrief = <<PURPOSEBRIEF;
Loads Anatomy Terms into DB and creates relationships among them.
PURPOSEBRIEF

my $purpose = <<PLUGIN_PURPOSE;
This plugin load anatomy from a file generated by DumpAnatomy and load them into the database.  Anatomy are organised into a graph and parent-child relationship are preserved.
PLUGIN_PURPOSE

my $tablesAffected =
	[['SRes.Anatomy', 'Anatomy terms are written here'],
	 ['SRes.ExternalDatabaseRelease', 'The user can optionally specify to create a new entry in this table when loading the anatomy'],
	 ['SRes.ExternalDatabase', 'The user can optionally specify to create a new entry in this table when loading the anatomy']];

my $tablesDependedOn = [ ];



my $argsDeclaration = [
		       fileArg({name => 'inputFile',
				descr => 'The anatomy file to be loaded',
				reqd => 1,
				constraintFunc => undef,
				isList => 0,
				mustExist => 1,
				format => 'see NOTES'
			    }),
		       
		       booleanArg({ name => 'createRelease',
				    descr => 'Set this to automatically create an external database release id for this version of the Anatomy file you are loading',
				    reqd => 0,
				    default => 0
				    })
		       
		       ];

my $howToRestart = <<PLUGIN_RESTART;
Restart the plugin.
PLUGIN_RESTART

my $failureCases = <<PLUGIN_FAILURE_CASES;
Unknown.
PLUGIN_FAILURE_CASES

my $notes = <<PLUGIN_NOTES;
The file format is hierarchy:source:definition, with hierarchy a semicolon delimited list of hierarchical IDs. The format is defined in GUS::Community::Plugin::Report::DumpAnatomy.
PLUGIN_NOTES


my $documentation = {purposeBrief => $purposeBrief,
		     purpose => $purpose,
		     tablesAffected => $tablesAffected,
		     tablesDependedOn => $tablesDependedOn,
		     howToRestart => $howToRestart,
		     failureCases => $failureCases,
		     notes => $notes
		    };


################################################################
# new
################################################################
sub new {
    my ($class) = @_;
    my $self = {};
    bless($self, $class);
    
    $self->initialize(
		      {requiredDbVersion => 3.5,
		       cvsRevision =>  '$Revision: 5215 $', #CVS fills this in
		       name => ref($self),
		       argsDeclaration   => $argsDeclaration,
		       documentation     => $documentation,
		   });
    
    return $self;
}


################################################################
# run
################################################################
sub run {
    my ($self) = @_;
           
    $self->readFile($self->getArg('inputFile'));
    
    my $msg = "done";
    return $msg;
}


sub readFile {
    my ($self, $fileName) = @_;
    
    open (FILE, "<$fileName"); 
    
    my @data = <FILE>;
    chomp @data;
    close(FILE);
    
    print "parsing data file...\n";
    
    foreach(@data) {
	my @cur = split(/\:/, $_);
	my @ids = split(/\;/, $cur[0]);
	my $source = $cur[1];
	my $description = $cur[2];
	
	#print "currentID = [@ids] source=$source desc=$description\n";
	my $currentID = $ids[$#ids];
	my $hierLevel = $#ids;
	
	$self->log("cur element = $currentID (her level = $hierLevel)");
	
        # test if this term is already in the db
	
	my $sql = "SELECT * FROM SRes.Anatomy WHERE NAME = '$currentID' AND HIER_LEVEL = $hierLevel";
	if($hierLevel != 0) {
	    for(my $i=1; $i<scalar @ids; $i++) {
		$sql = $sql." AND LEVEL_$i = '$ids[$i]'";
	    }
	}
	
	#print "**** Query = $sql\n";
	
	my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
	my ($result) = $sth->fetchrow_array();
	
	if(!defined $result) {
	    $self->log("term '$currentID' not in the db, so populate the db\n");
	    
	    # check if the immediate parent is in the db and get its id
	    my $parentID;
	    
	    if($#ids>0) {
		my $parentName = $ids[$#ids-1];
		my $parentHierLevel = $#ids-1;
		
		my $sql = "SELECT ANATOMY_ID FROM SRes.Anatomy WHERE NAME = '$parentName' AND HIER_LEVEL = $parentHierLevel";
		if($parentHierLevel>0) {
		    for(my $i=1; $i<scalar @ids-1; $i++) {
			$sql = $sql." AND LEVEL_$i = '$ids[$i]'";
		    }
		}
		
		#print "**** Parent Query = $sql\n";
		my $sth = $self->getQueryHandle()->prepareAndExecute($sql);
		$parentID = $sth->fetchrow_array();
		
		if(!defined $parentID) {
		    die "parent '$parentName' of '$currentID' not in the database\n"; 
		}
	    }
	    
	    #populate entry
	    my $newAnatomy = GUS::Model::SRes::Anatomy->new({
		'name'        => $currentID,
		'hier_level'  => $hierLevel,
		'parent_ID'    => $parentID,
		'source'      => $source,
		'description'  => $description,
	    });
	    
	    if($hierLevel != 0) {
		for(my $i=1; $i<scalar @ids; $i++) {
		    my $attributeName = "level_$i";
		    $newAnatomy->set($attributeName, "$ids[$i]");
		}
	    }
	    
	    $newAnatomy->submit();
	    
	}
	else {
	    $self->log("term '$currentID' already in DB\n");
	}
    }
}
